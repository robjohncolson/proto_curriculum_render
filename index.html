<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AP Stats Consensus Quiz</title>
    
    <link rel="stylesheet" href="css/styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    <script src="js/charts.js"></script>

</head>
<body>
    <div class="container">
        <h1>🧮 AP Statistics Consensus Quiz</h1>
        <div id="messageArea"></div>
        <div id="questionsContainer"></div>
    </div>

    <button class="theme-toggle" onclick="toggleTheme()" title="Toggle theme">🌙</button>
    <button class="sync-button" onclick="showSyncModal()" title="Sync & Export Data">⚡</button>
    <button class="share-button" onclick="showShareModal()" title="Share this app">📤</button>

    <!-- Global Sync Modal -->
    <div id="syncModal" class="modal" style="display: none;">
        <div class="modal-content">
            <span class="close-modal">&times;</span>
            <h2><i class="fas fa-sync"></i> Data Management</h2>
            <p>Current user: <strong id="currentUserDisplay"></strong></p>

            <div class="sync-section">
                <h3><i class="fas fa-user"></i> Student Actions</h3>
                <div class="sync-buttons">
                    <button id="saveBtn" class="modal-btn">
                        <i class="fas fa-save"></i>
                        <span>
                            <strong>Save</strong>
                            <small>Export your personal data</small>
                        </span>
                    </button>
                    <button id="openBtn" class="modal-btn">
                        <i class="fas fa-folder-open"></i>
                        <span>
                            <strong>Open</strong>
                            <small>Import any database file</small>
                        </span>
                    </button>
                </div>
            </div>

            <div class="sync-section">
                <h3><i class="fas fa-chalkboard-teacher"></i> Teacher Actions</h3>
                <div class="sync-buttons">
                    <button id="masterExportBtn" class="modal-btn">
                        <i class="fas fa-database"></i>
                        <span>
                            <strong>Master Export</strong>
                            <small>Export all users' data</small>
                        </span>
                    </button>
                    <button id="masterImportBtn" class="modal-btn">
                        <i class="fas fa-cloud-download-alt"></i>
                        <span>
                            <strong>Master Import</strong>
                            <small>Import peer data from master database</small>
                        </span>
                    </button>
                </div>
            </div>

            <div class="sync-footer">
                <small><i class="fas fa-keyboard"></i> Tip: Press Ctrl+S to quickly access sync options</small>
            </div>
        </div>
    </div>

    <!-- Share Modal -->
    <div id="shareModal" class="modal" style="display: none;">
        <div class="modal-content share-modal-content">
            <span class="close-modal" onclick="closeShareModal()">&times;</span>
            <h2>📤 Share AP Stats Consensus Quiz</h2>

            <div class="share-description">
                <p><strong>A collaborative learning platform for AP Statistics</strong></p>
                <p>Share with your classmates to see consensus responses and learn together!</p>
            </div>

            <div class="share-sections">
                <!-- Website Section -->
                <div class="share-section">
                    <h3>🌐 Visit the Website</h3>
                    <div class="share-url-container">
                        <input type="text" id="websiteUrl" class="share-url-input" value="https://robjohncolson.github.io/curriculum_render" readonly>
                        <button class="copy-btn" onclick="copyToClipboard('websiteUrl', 'Website URL')">📋 Copy</button>
                    </div>
                    <div class="qr-code-container" id="websiteQR"></div>
                    <p class="share-instruction">Scan QR code or visit the URL to access the app</p>
                </div>

                <!-- GitHub Section -->
                <div class="share-section">
                    <h3>💻 View Source Code</h3>
                    <div class="share-url-container">
                        <input type="text" id="githubUrl" class="share-url-input" value="https://github.com/robjohncolson/curriculum_render" readonly>
                        <button class="copy-btn" onclick="copyToClipboard('githubUrl', 'GitHub URL')">📋 Copy</button>
                    </div>
                    <div class="qr-code-container" id="githubQR"></div>
                    <p class="share-instruction">GitHub repository contains source code and documentation</p>
                </div>
            </div>

            <!-- Current Location Section (always shown) -->
            <div id="currentLocationSection" class="current-location-wrapper">
                <div class="share-section current-location-section">
                    <h3 id="locationTitle">📍 Current Location</h3>
                    <div class="share-url-container">
                        <input type="text" id="currentLocation" class="share-url-input" value="" readonly>
                        <button class="copy-btn" onclick="copyToClipboard('currentLocation', 'Current location')">📋 Copy</button>
                    </div>
                    <p class="share-instruction" id="locationDescription">Loading location...</p>
                    <div id="locationInfo" class="location-info" style="display: none;">
                        <!-- Dynamic content will be added here -->
                    </div>
                </div>
            </div>

            <div class="share-footer">
                <small>💡 Teachers can export master databases for class-wide analysis</small>
                <br>
                <small>Version 2.0 | Created for AP Statistics Students</small>
            </div>
        </div>
    </div>

<script src="data/curriculum.js"></script>
    <script src="data/units.js"></script>
    <script>
      
        // Helper functions for charts
        function generateChartColors(count) {
            const colors = [
                '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF',
                '#FF9F40', '#FF6384', '#C9CBCF', '#4BC0C0', '#FF6384'
            ];
            const result = [];
            for (let i = 0; i < count; i++) {
                result.push(colors[i % colors.length]);
            }
            return result;
        }

        function isDarkMode() {
            return document.body.classList.contains('dark-theme');
        }

        function getTextColor() {
            return isDarkMode() ? '#e0e0e0' : '#333333';
        }

        function getGridColor() {
            return isDarkMode() ? '#444444' : '#e0e0e0';
        }

        function getScatterPointColor() {
            return isDarkMode() ? '#5BC0EB' : '#36A2EB';
        }

        // Username Generation
        const fruits = ['Apple', 'Banana', 'Cherry', 'Grape', 'Lemon', 'Mango', 'Orange', 'Peach', 'Pear', 'Plum', 'Berry', 'Melon', 'Kiwi', 'Lime', 'Papaya', 'Guava', 'Apricot', 'Date', 'Fig', 'Coconut'];
        const animals = ['Bear', 'Cat', 'Dog', 'Eagle', 'Fox', 'Goat', 'Horse', 'Iguana', 'Jaguar', 'Koala', 'Lion', 'Monkey', 'Newt', 'Owl', 'Panda', 'Quail', 'Rabbit', 'Snake', 'Tiger', 'Wolf'];

        function generateRandomUsername() {
            const fruit = fruits[Math.floor(Math.random() * fruits.length)];
            const animal = animals[Math.floor(Math.random() * animals.length)];
            return `${fruit}_${animal}`;
        }

        // Global variables
        let currentUsername = null;
        let classData = null;
        let currentUnit = null;
        let currentLesson = null;
        let currentQuestions = [];
        let allUnitQuestions = [];
        let chartInstances = {};
        let currentTheme = 'light';

        // Add this to your global variables
        let allCurriculumData = {}; // Store all units' data
        let qrCodesGenerated = false; // Track if QR codes have been generated


        // Share Modal Functions
        function showShareModal() {
            const modal = document.getElementById('shareModal');
            modal.style.display = 'block';

            // Check if running locally and show local file path
            detectLocalFile();

            // Generate QR codes if not already generated
            if (!qrCodesGenerated) {
                generateQRCodes();
                qrCodesGenerated = true;
            }
        }

        function detectLocalFile() {
            const locationSection = document.querySelector('.current-location-section');
            const locationTitle = document.getElementById('locationTitle');
            const locationInput = document.getElementById('currentLocation');
            const locationDescription = document.getElementById('locationDescription');
            const locationInfo = document.getElementById('locationInfo');

            // Check if running from file:// protocol
            if (window.location.protocol === 'file:') {
                // RUNNING LOCALLY
                locationSection.classList.add('local-mode');
                locationSection.classList.remove('web-mode');
                locationTitle.innerHTML = '📁 Local File Location';

                // Get the local file path
                let localPath = window.location.href;

                // Clean up the path for better display
                localPath = localPath.replace('file:///', '');
                // On Windows, fix the drive letter format
                if (localPath.match(/^[A-Z]:/)) {
                    localPath = localPath.replace(/\//g, '\\');
                }
                // Decode URL encoding (spaces, special characters)
                localPath = decodeURIComponent(localPath);

                // Get just the directory path (remove index.html)
                const directoryPath = localPath.substring(0, localPath.lastIndexOf('/')) ||
                                    localPath.substring(0, localPath.lastIndexOf('\\'));

                locationInput.value = directoryPath || localPath;
                locationDescription.innerHTML = '🖥️ Running from your local computer';

                // Show local sharing instructions
                locationInfo.innerHTML = `
                    <p><strong>Share with classmates:</strong></p>
                    <ul style="text-align: left; margin: 10px auto; max-width: 400px;">
                        <li>Copy this entire folder to a USB drive</li>
                        <li>Upload the folder to a shared drive</li>
                        <li>Or use the GitHub repository above</li>
                    </ul>
                    <button onclick="openLocalFolder()" style="
                        margin-top: 15px;
                        background: white;
                        color: #e67e22;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 5px;
                        cursor: pointer;
                        font-weight: bold;
                    ">📂 Open Folder Location</button>
                `;
                locationInfo.style.display = 'block';
            } else {
                // RUNNING FROM WEB
                locationSection.classList.add('web-mode');
                locationSection.classList.remove('local-mode');
                locationTitle.innerHTML = '🌐 Current Web Location';

                // Get the current URL
                const currentUrl = window.location.href;
                const hostname = window.location.hostname;

                locationInput.value = currentUrl;

                // Check if it's the official GitHub Pages site
                if (hostname === 'robjohncolson.github.io') {
                    locationDescription.innerHTML = '✅ Running from the official website';
                    locationInfo.innerHTML = `
                        <p><strong>You're using the live version!</strong></p>
                        <ul style="text-align: left; margin: 10px auto; max-width: 400px;">
                            <li>Bookmark this page for easy access</li>
                            <li>Share the URL with classmates</li>
                            <li>No installation needed!</li>
                        </ul>
                    `;
                } else {
                    locationDescription.innerHTML = `🌍 Running from: ${hostname}`;
                    locationInfo.innerHTML = `
                        <p><strong>Custom deployment detected</strong></p>
                        <ul style="text-align: left; margin: 10px auto; max-width: 400px;">
                            <li>This appears to be a custom deployment</li>
                            <li>Make sure you trust this source</li>
                            <li>Official site: robjohncolson.github.io</li>
                        </ul>
                    `;
                }
                locationInfo.style.display = 'block';
            }
        }

        function closeShareModal() {
            const modal = document.getElementById('shareModal');
            modal.style.display = 'none';
        }

        function generateQRCodes() {
            // Clear any existing QR codes
            document.getElementById('websiteQR').innerHTML = '';
            document.getElementById('githubQR').innerHTML = '';

            // Generate website QR code
            new QRCode(document.getElementById('websiteQR'), {
                text: 'https://robjohncolson.github.io/curriculum_render',
                width: 200,
                height: 200,
                colorDark: isDarkMode() ? '#ff69b4' : '#3498db',
                colorLight: isDarkMode() ? '#2a2a2a' : '#ffffff',
                correctLevel: QRCode.CorrectLevel.H
            });

            // Generate GitHub QR code
            new QRCode(document.getElementById('githubQR'), {
                text: 'https://github.com/robjohncolson/curriculum_render',
                width: 200,
                height: 200,
                colorDark: isDarkMode() ? '#ff69b4' : '#3498db',
                colorLight: isDarkMode() ? '#2a2a2a' : '#ffffff',
                correctLevel: QRCode.CorrectLevel.H
            });
        }

        function copyToClipboard(elementId, label) {
            const input = document.getElementById(elementId);
            input.select();
            input.setSelectionRange(0, 99999); // For mobile devices

            try {
                document.execCommand('copy');
                showMessage(`${label} copied to clipboard!`, 'success');
            } catch (err) {
                // Fallback for newer browsers
                navigator.clipboard.writeText(input.value).then(function() {
                    showMessage(`${label} copied to clipboard!`, 'success');
                }, function(err) {
                    showMessage('Failed to copy URL', 'error');
                });
            }
        }

        function showMessage(message, type = 'info') {
            const messageArea = document.getElementById('messageArea');
            if (messageArea) {
                messageArea.innerHTML = `<div class="message ${type}">${message}</div>`;
                setTimeout(() => {
                    messageArea.innerHTML = '';
                }, 3000);
            }
        }

        function openLocalFolder() {
            const localPath = document.getElementById('currentLocation').value;

            // Try to open the folder in the system's file explorer
            // Note: This has limitations due to browser security
            if (localPath) {
                // For Windows, create a file:// URL with proper formatting
                let folderUrl;
                if (localPath.includes('\\')) {
                    // Windows path
                    folderUrl = 'file:///' + localPath.replace(/\\/g, '/');
                } else {
                    // Unix/Mac path
                    folderUrl = 'file://' + localPath;
                }

                // Try to open in a new window (may be blocked by browser)
                const opened = window.open(folderUrl, '_blank');

                if (!opened) {
                    showMessage('Cannot open folder directly. Please copy the path and open manually in your file explorer.', 'info');
                }
            }
        }


        // Unit structure - defines lessons per unit
        const unitStructure = {
            1: { name: 'Exploring One-Variable Data', lessons: 5 },
            2: { name: 'Exploring Two-Variable Data', lessons: 4 },
            3: { name: 'Collecting Data', lessons: 3 },
            4: { name: 'Probability & Random Variables', lessons: 5 },
            5: { name: 'Sampling Distributions', lessons: 4 },
            6: { name: 'Inference for Proportions', lessons: 4 },
            7: { name: 'Inference for Means', lessons: 4 },
            8: { name: 'Chi-Square Tests', lessons: 2 },
            9: { name: 'Inference for Slopes', lessons: 2 }
        };

        // Initialize class data
        function initClassData() {
            let classDataStr = localStorage.getItem('classData');
            classData = classDataStr ? JSON.parse(classDataStr) : {users: {}};

            if (!classData.users[currentUsername]) {
                classData.users[currentUsername] = {
                    answers: {},
                    reasons: {},
                    timestamps: {},
                    attempts: {}
                };
            }

            saveClassData();
        }

        function saveClassData() {
            try {
                localStorage.setItem('classData', JSON.stringify(classData));
            } catch(e) {
                console.log("Storage quota exceeded");
                showMessage("Warning: Local storage is full. Some data may not be saved.", 'error');
            }
        }

        // Student Performance Badges
        function calculateBadges(username) {
            const userAnswers = classData.users[username]?.answers || {};
            const userReasons = classData.users[username]?.reasons || {};
            const userAttempts = classData.users[username]?.attempts || {};

            const totalAnswers = Object.keys(userAnswers).length;
            if (totalAnswers === 0) return [];

            const badges = [];

            // Calculate outlier/conformist
            let modeMatches = 0;
            let outlierCount = 0;

            Object.keys(userAnswers).forEach(qId => {
                const allAnswers = Object.values(classData.users)
                    .map(u => u.answers?.[qId]?.value || u.answers?.[qId])
                    .filter(a => a);

                if (allAnswers.length > 1) {
                    const mode = getMostFrequent(allAnswers);
                    const userAnswer = userAnswers[qId]?.value || userAnswers[qId];
                    if (userAnswer === mode) modeMatches++;
                    else outlierCount++;
                }
            });

            if (outlierCount > totalAnswers * 0.5) badges.push('🎯 Outlier');
            if (modeMatches > totalAnswers * 0.8) badges.push('👥 Conformist');

            // Explorer badge
            const multiAttempts = Object.values(userAttempts).filter(a => a >= 2).length;
            if (multiAttempts > totalAnswers * 0.3) badges.push('🔄 Explorer');

            // Silent type vs Debater
            const reasonCount = Object.values(userReasons).filter(r => r && r.trim()).length;
            if (reasonCount < totalAnswers * 0.2) badges.push('🤐 Silent Type');
            else if (reasonCount > totalAnswers * 0.8) badges.push('💬 Debater');

            // Completionist
            const totalQuestions = currentQuestions.length;
            if (totalAnswers === totalQuestions && totalQuestions > 0) badges.push('✅ Completionist');

            return badges;
        }

        function getMostFrequent(arr) {
            const counts = {};
            arr.forEach(x => counts[x] = (counts[x] || 0) + 1);
            return Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b);
        }

        // Check if question has been answered
        function isQuestionAnswered(questionId) {
            return classData.users[currentUsername]?.answers?.[questionId] !== undefined;
        }

        // Get attempt count for a question
        function getAttemptCount(questionId) {
            return classData.users[currentUsername]?.attempts?.[questionId] || 0;
        }

        // Check if can retry (has reason in previous attempt and < 3 attempts)
        function canRetry(questionId) {
            const attempts = getAttemptCount(questionId);
            if (attempts >= 3) return false;
            if (attempts === 0) return true;
            
            // Check if previous attempt had a reason
            const previousReason = classData.users[currentUsername]?.reasons?.[questionId];
            return previousReason && previousReason.trim().length > 0;
        }
        // Replace the entire detectUnitAndLessons function:
        function detectUnitAndLessons(questions) {
            if (!questions || questions.length === 0) return null;

            const firstId = questions[0].id;
            const unitMatch = firstId.match(/U(\d+)/i);
            if (!unitMatch) return null;

            const unitNum = parseInt(unitMatch[1]);

            // Group questions by lesson
            const lessonGroups = {};
            questions.forEach(q => {
                let lessonIdentifier;

                // Check for Progress Check questions first
                if (q.id.includes('-PC-')) {
                    lessonIdentifier = 'PC';
                } else {
                    // Match standard lesson format: U#-L#-
                    const lessonMatch = q.id.match(/U\d+-L(\d+)-/);
                    if (lessonMatch) {
                        lessonIdentifier = parseInt(lessonMatch[1]);
                    }
                }

                if (lessonIdentifier !== undefined) {
                    if (!lessonGroups[lessonIdentifier]) {
                        lessonGroups[lessonIdentifier] = [];
                    }
                    lessonGroups[lessonIdentifier].push(q);
                }
            });

            // Sort lesson numbers properly, with PC at the end
            const numericLessons = Object.keys(lessonGroups)
                .filter(key => typeof key === 'number' || !isNaN(key))
                .map(n => parseInt(n))
                .sort((a, b) => a - b);

            const allLessons = numericLessons.concat(lessonGroups['PC'] ? ['PC'] : []);

            console.log('Detected lessons:', allLessons); // Debug log
            console.log('Lesson groups:', Object.keys(lessonGroups)); // Debug log

            return {
                unitNumber: unitNum,
                lessons: lessonGroups,
                lessonNumbers: allLessons
            };
        }


       



        // Username management
        function promptUsername() {
            const savedUsername = localStorage.getItem('consensusUsername');
            if (savedUsername) {
                currentUsername = savedUsername;
                initClassData();
                initializeProgressTracking(); // Initialize progress tracking for returning user
                showUsernameWelcome();
                initializeFromEmbeddedData(); // Initialize from embedded data
                updateCurrentUsernameDisplay();
            } else {
                showUsernamePrompt();
            }
        }

        function showUsernamePrompt() {
            const suggestedName = generateRandomUsername();
            const questionsContainer = document.getElementById('questionsContainer');
            questionsContainer.innerHTML = `
                <div class="username-prompt-enhanced">
                    <div class="welcome-header">
                        <h1>📊 AP Statistics Consensus Quiz</h1>
                        <p class="subtitle">Collaborative Learning Platform</p>
                    </div>

                    <!-- Returning User Section -->
                    <div class="user-section returning-user">
                        <h2>🔄 Returning Student?</h2>
                        <p>Restore your data from a master database file:</p>

                        <div class="recovery-options">
                            <!-- CSV Import - renamed to Restore -->
                            <div class="recovery-option">
                                <div class="option-icon">🔄</div>
                                <h3>Restore</h3>
                                <p class="option-description">Import master data using CSV student roster</p>
                                <button onclick="showRestoreOptionsModal()"
                                        class="action-button primary">
                                    Restore Data
                                </button>
                            </div>
                        </div>

                        <!-- Recently Used Usernames (if any in localStorage) -->
                        <div id="recentUsernames" style="display: none;">
                            <h3>📝 Recently Used on This Device:</h3>
                            <div id="recentUsernamesList"></div>
                        </div>
                    </div>

                    <!-- New User Section -->
                    <div class="user-section new-user">
                        <h2>🆕 New Student?</h2>
                        <p>Generate a unique username to get started:</p>

                        <div class="name-generator">
                            <div class="generated-name-display">
                                <span class="name-label">Your Username:</span>
                                <span class="generated-name" id="generatedName">${suggestedName}</span>
                            </div>

                            <div class="generator-buttons">
                                <button onclick="acceptUsername('${suggestedName}')" class="action-button primary large">
                                    <span class="button-icon">✅</span>
                                    Accept & Start
                                </button>
                                <button onclick="rerollUsername()" class="action-button secondary">
                                    <span class="button-icon">🎲</span>
                                    Generate New
                                </button>
                            </div>

                            <div class="name-explanation">
                                <small>💡 Tip: Write down your username or export it for future use!</small>
                            </div>
                        </div>
                    </div>

                </div>
            `;

            // Check for recently used usernames
            loadRecentUsernames();
        }

        window.rerollUsername = function() {
            const newName = generateRandomUsername();
            const generatedNameElement = document.getElementById('generatedName');
            if (generatedNameElement) {
                generatedNameElement.textContent = newName;
                // Update the accept button to use the new name
                const acceptButton = generatedNameElement.closest('.name-generator').querySelector('.action-button.primary.large');
                if (acceptButton) {
                    acceptButton.onclick = () => acceptUsername(newName);
                }
            } else {
                // Fallback to full refresh if element not found
                showUsernamePrompt();
            }
        }

        window.acceptUsername = function(name) {
            currentUsername = name;
            localStorage.setItem('consensusUsername', currentUsername);
            initClassData();
            initializeProgressTracking(); // Initialize progress tracking for new session
            showUsernameWelcome();
            initializeFromEmbeddedData();
            updateCurrentUsernameDisplay();
        }

        // Function to recover username from manual input
        window.recoverUsername = function() {
            const input = document.getElementById('manualUsername');
            const username = input.value.trim();

            if (!username) {
                showMessage('Please enter a username', 'error');
                return;
            }

            // Validate username format (optional)
            if (!username.match(/^[A-Za-z]+_[A-Za-z]+$/)) {
                if (!confirm('This username doesn\'t match the standard format (Fruit_Animal). Use it anyway?')) {
                    return;
                }
            }

            // Check if this username has existing data
            checkExistingData(username);
        }

        // Function to check for existing data
        function checkExistingData(username) {
            const existingData = localStorage.getItem(`answers_${username}`);
            const classData = JSON.parse(localStorage.getItem('classData') || '{}');
            const hasData = existingData || (classData.users && classData.users[username]);

            if (hasData) {
                if (confirm(`Found existing data for ${username}. Would you like to continue with this username and restore your progress?`)) {
                    acceptUsername(username);
                    showMessage('Welcome back! Your progress has been restored.', 'success');
                }
            } else {
                if (confirm(`No existing data found for ${username}. Would you like to start fresh with this username?`)) {
                    acceptUsername(username);
                    showMessage('Username set! Starting fresh.', 'info');
                }
            }
        }

        // Function to import username from file
        window.importUsernameFromFile = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);

                    // Try to find username in various formats
                    let username = null;

                    // Check for direct username field (personal export)
                    if (data.username) {
                        username = data.username;
                    }
                    // Check for master export format with exportTime and students
                    else if (data.exportTime && data.students) {
                        const usernames = Object.keys(data.students);
                        if (usernames.length === 1) {
                            username = usernames[0];
                        } else if (usernames.length > 1) {
                            // Show selection dialog for multiple users
                            showUsernameSelection(usernames, data);
                            return;
                        }
                    }
                    // Check for master database format with exportType
                    else if (data.exportType === 'master_database' && data.allUsers) {
                        if (data.allUsers.length === 1) {
                            username = data.allUsers[0];
                        } else if (data.allUsers.length > 1) {
                            showUsernameSelection(data.allUsers, data);
                            return;
                        }
                    }
                    // Check for class data format with users field
                    else if (data.users) {
                        const usernames = Object.keys(data.users);
                        if (usernames.length === 1) {
                            username = usernames[0];
                        } else if (usernames.length > 0) {
                            showUsernameSelection(usernames, data);
                            return;
                        }
                    }
                    // Check for students field (alternative format)
                    else if (data.students) {
                        const usernames = Object.keys(data.students);
                        if (usernames.length === 1) {
                            username = usernames[0];
                        } else if (usernames.length > 0) {
                            showUsernameSelection(usernames, data);
                            return;
                        }
                    }

                    if (username) {
                        // If we found a single username, import the data directly
                        importDataForUser(username, data);
                    } else {
                        showMessage('No username found in this file', 'error');
                    }

                } catch (error) {
                    showMessage('Invalid file format', 'error');
                }
            };
            reader.readAsText(file);
        }

        // Function to show username selection dialog
        // Store import data globally for use after username selection
        let pendingImportData = null;

        function showUsernameSelection(usernames, importData = null) {
            // Store the import data for later use
            pendingImportData = importData;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';

            let optionsHTML = usernames.map(u =>
                `<button onclick="selectUsername('${u}')" class="username-option">
                    ${u}
                </button>`
            ).join('');

            modal.innerHTML = `
                <div class="modal-content">
                    <span class="close-modal" onclick="closeUsernameSelection()">&times;</span>
                    <h3>Select Your Username</h3>
                    <p>Multiple usernames found. Please select yours:</p>
                    <div class="username-options">
                        ${optionsHTML}
                    </div>
                    ${importData ? '<p><small>After selection, your data will be imported.</small></p>' : ''}
                </div>
            `;

            document.body.appendChild(modal);
        }

        window.selectUsername = function(username) {
            document.querySelector('.modal').remove();

            // If we have pending import data, import it first
            if (pendingImportData) {
                importDataForUser(username, pendingImportData);
                pendingImportData = null;
            } else {
                checkExistingData(username);
            }
        }

        window.closeUsernameSelection = function() {
            document.querySelector('.modal').remove();
            pendingImportData = null;
        }

        // --- Start of New Code for Phase 2 (Revised) ---

        function showRestoreOptionsModal() {
            // Prevent creating duplicate modals
            if (document.getElementById('restoreOptionsModal')) {
                return;
            }

            const modal = document.createElement('div');
            modal.id = 'restoreOptionsModal';
            modal.className = 'modal';

            // Using the exact HTML structure you provided in Phase 1
            modal.innerHTML = `
                <div class="modal-content enhanced-sync-modal">
                    <span class="close-modal" onclick="closeRestoreOptionsModal()">&times;</span>
                    <h3>Choose Restore Method</h3>

                    <div class="restore-option">
                        <h4>🏫 Classroom Restore</h4>
                        <p>Your teacher has a master file and a class roster to restore your account.</p>
                        <button class="action-button primary" onclick="showCSVImportModal(); closeRestoreOptionsModal();">
                            Use Classroom File
                        </button>
                    </div>

                    <div class="restore-option">
                        <h4>💾 Personal Restore</h4>
                        <p>You have your username and your personal backup (.json) file.</p>
                        <input type="text" id="manualUsernameInput" class="username-input"
                               placeholder="Enter your username (e.g., Apple_Bear)">
                        <button id="continueWithUsernameBtn" class="action-button primary">
                            Continue to Import
                        </button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
            modal.style.display = 'block';

           // --- Start of New Code for Phase 3 (Revised) ---

// Attach the event listener for the "Continue to Import" button now that it exists in the DOM.
const continueBtn = document.getElementById('continueWithUsernameBtn');
if (continueBtn) {
    continueBtn.onclick = function() {
        const usernameInput = document.getElementById('manualUsernameInput');
        const username = usernameInput.value.trim();

        // 1. Validate that the username is not empty.
        if (!username) {
            // Use the existing showMessage function for consistent UI feedback.
            if (typeof showMessage === 'function') {
                showMessage('Please enter a username to continue.', 'error');
            } else {
                alert('Please enter a username to continue.');
            }
            return;
        }
        
        // 2. Call the existing `acceptUsername` function to establish the session.
        // CRITICAL: We use the username with its original capitalization to match the "Fruit_Animal" format.
        acceptUsername(username);
        
        // 3. Close the modal.
        closeRestoreOptionsModal();

        // 4. Display a helpful guidance message to the user.
        if (typeof showMessage === 'function') {
            showMessage(`Welcome, ${username}! Use the Sync button (⚡️) to import your personal backup file.`, 'info');
        }
    };
}

// --- End of New Code for Phase 3 (Revised) ---

            // Automatically focus the input field for a better user experience
            const usernameInput = document.getElementById('manualUsernameInput');
            if (usernameInput) {
                usernameInput.focus();
            }
        }

        function closeRestoreOptionsModal() {
            const modal = document.getElementById('restoreOptionsModal');
            if (modal) {
                modal.remove();
            }
        }

        // --- End of New Code for Phase 2 (Revised) ---/
        // / --- Start of mergePersonalData Function for Phase 4.1 ---

  /**
   * Merges two user data objects with non-destructive timestamp-based logic.
   * This function implements the approved merge rules for handling multiple personal backup imports.
   * 
   * @param {Object} existingUserData - The current user's data from classData.users[username]
   * @param {Object} newUserData - The incoming user data from an imported file
   * @returns {Object} The merged user data object with the most recent/relevant information
   */
  function mergePersonalData(existingUserData, newUserData) {
      try {
          console.log('=== Starting mergePersonalData ===');

          // 1. Initialization and Edge Cases
          // If no existing data, return the new data immediately
          if (!existingUserData || Object.keys(existingUserData).length === 0) {
              console.log('No existing data found, returning new data as-is');
              return newUserData || {};
          }

          // If no new data, return existing data
          if (!newUserData || Object.keys(newUserData).length === 0) {
              console.log('No new data to merge, returning existing data');
              return existingUserData;
          }

          // Create a deep copy of existingUserData to avoid mutations
          let mergedUserData = JSON.parse(JSON.stringify(existingUserData));

          // Ensure all primary keys exist on mergedUserData
          mergedUserData.answers = mergedUserData.answers || {};
          mergedUserData.reasons = mergedUserData.reasons || {};
          mergedUserData.timestamps = mergedUserData.timestamps || {};
          mergedUserData.attempts = mergedUserData.attempts || {};
          mergedUserData.progress = mergedUserData.progress || {};
          mergedUserData.badges = mergedUserData.badges || {};
          mergedUserData.preferences = mergedUserData.preferences || {};

          // Also ensure newUserData has these structures for safe access
          newUserData.answers = newUserData.answers || {};
          newUserData.reasons = newUserData.reasons || {};
          newUserData.timestamps = newUserData.timestamps || {};
          newUserData.attempts = newUserData.attempts || {};
          newUserData.progress = newUserData.progress || {};

          // 2. Merge Answers, Timestamps, and Reasons
          console.log('Merging answers based on timestamps...');
          let answersUpdated = 0;

          for (const questionId in newUserData.answers) {
              try {
                  const newAnswer = newUserData.answers[questionId];
                  const existingAnswer = mergedUserData.answers[questionId];

                  // Extract timestamps - handle both direct timestamps and answer objects with timestamp property
                  let newTimestamp = null;
                  let existingTimestamp = null;

                  // Check for timestamp in various possible locations
                  if (newAnswer && typeof newAnswer === 'object' && newAnswer.timestamp) {
                      newTimestamp = newAnswer.timestamp;
                  } else if (newUserData.timestamps && newUserData.timestamps[questionId]) {
                      newTimestamp = newUserData.timestamps[questionId];
                  }

                  if (existingAnswer && typeof existingAnswer === 'object' && existingAnswer.timestamp) {
                      existingTimestamp = existingAnswer.timestamp;
                  } else if (mergedUserData.timestamps && mergedUserData.timestamps[questionId]) {
                      existingTimestamp = mergedUserData.timestamps[questionId];
                  }

                  // Convert timestamps to numbers for comparison
                  newTimestamp = Number(newTimestamp) || 0;
                  existingTimestamp = Number(existingTimestamp) || 0;

                  // Rule: If new answer is more recent (or no existing answer), update all related fields
                  if (!existingAnswer || newTimestamp > existingTimestamp) {
                      mergedUserData.answers[questionId] = newAnswer;
                      mergedUserData.timestamps[questionId] = newTimestamp || newUserData.timestamps[questionId];

                      // Update reason if it exists for this question
                      if (newUserData.reasons && newUserData.reasons[questionId]) {
                          mergedUserData.reasons[questionId] = newUserData.reasons[questionId];
                      }

                      answersUpdated++;
                      console.log(`  Updated ${questionId}: timestamp ${newTimestamp} > ${existingTimestamp}`);
                  } else if (newTimestamp === existingTimestamp && existingTimestamp > 0) {
                      // Edge Case: If timestamps are identical, preserve existing data
                      console.log(`  Preserved ${questionId}: timestamps identical (${existingTimestamp})`);
                  }

              } catch (answerError) {
                  console.error(`Error merging answer for ${questionId}:`, answerError);
                  // Continue processing other answers
              }
          }

          console.log(`Updated ${answersUpdated} answers based on timestamps`);

          // 3. Merge Attempts
          console.log('Merging attempt counts...');
          let attemptsUpdated = 0;

          for (const questionId in newUserData.attempts) {
              const existingAttempts = Number(mergedUserData.attempts[questionId]) || 0;
              const newAttempts = Number(newUserData.attempts[questionId]) || 0;

              // Rule: Keep the highest attempt count
              const maxAttempts = Math.max(existingAttempts, newAttempts);

              if (maxAttempts !== existingAttempts) {
                  mergedUserData.attempts[questionId] = maxAttempts;
                  attemptsUpdated++;
                  console.log(`  Updated attempts for ${questionId}: ${existingAttempts} -> ${maxAttempts}`);
              }
          }

          // Also check for attempts in existing data that aren't in new data
          for (const questionId in mergedUserData.attempts) {
              if (!(questionId in newUserData.attempts)) {
                  // Keep existing attempts for questions not in new data
                  console.log(`  Preserved attempts for ${questionId}: ${mergedUserData.attempts[questionId]}`);
              }
          }

          console.log(`Updated ${attemptsUpdated} attempt counts`);

          // 4. Merge Progress
          console.log('Merging progress indicators...');
          let progressUpdated = 0;

          for (const key in newUserData.progress) {
              const existingProgress = Number(mergedUserData.progress[key]) || 0;
              const newProgress = Number(newUserData.progress[key]) || 0;

              // Rule: Keep the maximum progress value
              const maxProgress = Math.max(existingProgress, newProgress);

              if (maxProgress !== existingProgress) {
                  mergedUserData.progress[key] = maxProgress;
                  progressUpdated++;
                  console.log(`  Updated progress.${key}: ${existingProgress} -> ${maxProgress}`);
              }
          }

          console.log(`Updated ${progressUpdated} progress indicators`);

          // 5. Merge Badges (bonus: merge unique badges, keeping earliest timestamp)
          if (newUserData.badges) {
              console.log('Merging badges...');
              mergedUserData.badges = mergedUserData.badges || {};

              for (const badge in newUserData.badges) {
                  if (!mergedUserData.badges[badge]) {
                      // New badge not in existing data
                      mergedUserData.badges[badge] = newUserData.badges[badge];
                      console.log(`  Added new badge: ${badge}`);
                  } else {
                      // Badge exists - keep the one with earlier timestamp (first earned)
                      const existingBadgeTime = mergedUserData.badges[badge].earnedAt || 0;
                      const newBadgeTime = newUserData.badges[badge].earnedAt || 0;

                      if (newBadgeTime && (!existingBadgeTime || newBadgeTime < existingBadgeTime)) {
                          mergedUserData.badges[badge] = newUserData.badges[badge];
                          console.log(`  Updated badge ${badge} with earlier timestamp`);
                      }
                  }
              }
          }

          // 6. Merge Preferences (use most recent)
          if (newUserData.preferences) {
              // For preferences, we'll take the entire new preferences object if it exists
              // as preferences are typically set as a complete unit
              mergedUserData.preferences = newUserData.preferences;
              console.log('Updated user preferences with latest values');
          }

          console.log('=== Merge complete ===');
          console.log(`Final merged data contains ${Object.keys(mergedUserData.answers).length} answers`);

          return mergedUserData;

      } catch (error) {
          console.error('Fatal error in mergePersonalData:', error);
          console.error('Stack trace:', error.stack);

          // In case of catastrophic failure, preserve existing data
          console.log('Returning existing data due to merge error');
          return existingUserData || {};
      }
  }

  // --- End of mergePersonalData Function for Phase 4.1 ---
    // --- Start of importAndMergePersonalData Function for Phase 4.2 ---

  /**
   * Wrapper function that imports personal data with non-destructive merging.
   * This function handles the integration of imported data using the mergePersonalData logic.
   * 
   * @param {Object} importedData - The imported user data object from a JSON file
   */
   function importAndMergePersonalData(importedData) {
      console.log('=== Starting importAndMergePersonalData ===');

      try {
          // 1. Get the currentUsername - if not set, show error and return
          if (!currentUsername) {
              showMessage('No username set. Please establish a session first.', 'error');
              console.error('No currentUsername set');
              return;
          }

          console.log('Processing import for username:', currentUsername);

          // 2. Load the entire classData object from localStorage
          let classData = JSON.parse(localStorage.getItem('classData') || '{}');

          // Ensure classData has the users object
          if (!classData.users) {
              classData.users = {};
          }

          // 3. Safely access the user's existing data slice
          let existingUserData = classData.users[currentUsername] || {};
          console.log('Existing user data keys:', Object.keys(existingUserData));

          // 4. Prepare the imported data for merging
          // First, check if importedData has the user's data nested inside
          let dataToMerge = null;

          // Handle different import formats
          if (importedData.users && importedData.users[currentUsername]) {
              // Data is in master export format with users object
              dataToMerge = importedData.users[currentUsername];
              console.log('Found user data in users object');
            } else if (importedData.username && importedData.username === currentUsername && importedData.users && importedData.users[currentUsername]) {
      // Personal export format with username field
      dataToMerge = importedData.users[currentUsername];
      console.log('Found user data in personal export format');
          } else if (importedData.username === currentUsername && importedData.answers) {
              // Data is in personal export format
              dataToMerge = {
                  answers: importedData.answers || {},
                  reasons: importedData.reasons || {},
                  timestamps: importedData.timestamps || {},
                  attempts: importedData.attempts || {},
                  progress: importedData.progress || {},
                  badges: importedData.badges || {},
                  preferences: importedData.preferences || {}
              };
              console.log('Using personal export format');
          } else if (importedData.answers) {
              // Direct data object format
              dataToMerge = importedData;
              console.log('Using direct data format');
          } else {
              showMessage('Could not find data for your username in the imported file.', 'error');
              console.error('No matching data found for username:', currentUsername);
              return;
          }

          // Migrate answers to standard format if the function exists
          if (typeof migrateAnswersToStandardFormat === 'function' && dataToMerge.answers) {
              console.log('Migrating answers to standard format...');
              dataToMerge.answers = migrateAnswersToStandardFormat(dataToMerge.answers);
          }

          // 5. Call mergePersonalData to merge the data
          console.log('Calling mergePersonalData...');
          let mergedUserData = mergePersonalData(existingUserData, dataToMerge);

          // 6. Update the main data structure in memory
          classData.users[currentUsername] = mergedUserData;
          console.log('Updated classData.users for', currentUsername);

          // 7. Save the entire updated classData object back to localStorage
          localStorage.setItem('classData', JSON.stringify(classData));
          console.log('Saved updated classData to localStorage');

          // 8. Call initClassData() to refresh global variables from the new state
          if (typeof initClassData === 'function') {
              initClassData();
              console.log('Reinitialized class data');
          }

          // 9. Refresh the UI with the merged data
          // Try to refresh visualizations if the function exists
          if (typeof refreshAllVisualizations === 'function') {
              refreshAllVisualizations();
              console.log('Refreshed all visualizations');
          } else if (typeof updateProgressDisplay === 'function') {
              updateProgressDisplay();
              console.log('Updated progress display');
          }

          // If we're on a question page, reload it to show the merged data
          if (typeof currentQuestionId !== 'undefined' && currentQuestionId) {
              if (typeof loadQuestion === 'function') {
                  // Extract topic and question number from currentQuestionId if possible
                  const parts = currentQuestionId.split('-');
                  if (parts.length >= 3) {
                      const topic = parts[0] + '-' + parts[1];
                      const questionNum = parseInt(parts[2].replace('Q', ''));
                      loadQuestion(topic, questionNum);
                      console.log('Reloaded current question');
                  }
              }
          }

          // 10. Show success message
          const answerCount = Object.keys(mergedUserData.answers || {}).length;
          showMessage(`Successfully merged your personal data! You now have ${answerCount} answers.`, 'success');
          console.log('=== Merge complete ===');
          console.log(`Final data contains ${answerCount} answers`);

      } catch (error) {
          console.error('Error in importAndMergePersonalData:', error);
          console.error('Stack trace:', error.stack);
          showMessage('Error merging personal data: ' + error.message, 'error');
      }
  }

  // --- End of importAndMergePersonalData Function for Phase 4.2 ---

        // Function to import data for a specific user
        function importDataForUser(username, importData) {
            console.log('=== importDataForUser called ===');
            console.log('Target username:', username);
            console.log('Import data:', importData);
            console.log('Import data keys:', Object.keys(importData));

            try {
                // Set the username first
                currentUsername = username;
                localStorage.setItem('consensusUsername', username);
                initClassData();

                let userData = null;
                let allStudentsData = {};
                let importSuccess = false;

                // Helper function to find username with case-insensitive matching
                function findUserData(dataObj, targetUsername) {
                    // Try exact match first
                    if (dataObj[targetUsername]) {
                        return { key: targetUsername, data: dataObj[targetUsername] };
                    }
                    // Try case-insensitive match
                    const lowerTarget = targetUsername.toLowerCase();
                    for (const key in dataObj) {
                        if (key.toLowerCase() === lowerTarget) {
                            console.log(`Found case-insensitive match: ${targetUsername} -> ${key}`);
                            return { key: key, data: dataObj[key] };
                        }
                    }
                    return null;
                }

                // DETECTION 1: Master file with "students" field (current format)
                if (importData.exportTime && importData.students) {
                    const userMatch = findUserData(importData.students, username);
                    if (userMatch) {
                        console.log('Detected: Master file with students field');
                        userData = userMatch.data;
                        allStudentsData = importData.students;
                        importSuccess = true;
                    }
                }
                // DETECTION 2: Legacy individual file with "users" field
                else if (importData.exportTime && importData.users) {
                    const userMatch = findUserData(importData.users, username);
                    if (userMatch) {
                        console.log('Detected: Legacy individual file with users field');
                        userData = userMatch.data;
                        allStudentsData = importData.users;
                        importSuccess = true;
                    }
                }
                // DETECTION 3: Master database export format
                else if (importData.exportType === 'master_database') {
                    console.log('Detected: Master database format');
                    if (importData.allAnswers && importData.allAnswers[username]) {
                        // STANDARDIZATION FIX: Use migration function for consistency
                        const standardizedAnswers = migrateAnswersToStandardFormat(importData.allAnswers[username]);
                        localStorage.setItem(`answers_${username}`, JSON.stringify(standardizedAnswers));
                        importSuccess = true;
                    }
                    if (importData.allProgress && importData.allProgress[username]) {
                        localStorage.setItem(`progress_${username}`, JSON.stringify(importData.allProgress[username]));
                    }
                    if (importData.classData) {
                        localStorage.setItem('classData', JSON.stringify(importData.classData));
                    }
                    showMessage(`Master database imported successfully for ${username}!`, 'success');
                }
                // DETECTION 4: Simple username-only format (fallback)
                else if (importData.username || importData.consensusUsername) {
                    console.log('Detected: Username-only format');
                    showMessage(`Username set to ${username} from import file.`, 'success');
                    importSuccess = true;
                }

                // Process user data if found (for formats 1 & 2)
                if (userData) {
                    console.log(`Processing user data for ${username}:`, userData);

                    // Import user's personal data to both individual keys AND classData structure
                    if (userData.answers) {
                        // STANDARDIZATION FIX: Use migration function for consistency
                        const standardizedAnswers = migrateAnswersToStandardFormat(userData.answers);
                        localStorage.setItem(`answers_${username}`, JSON.stringify(standardizedAnswers));
                        console.log(`Imported ${Object.keys(standardizedAnswers).length} answers for ${username} (standardized format)`);
                    }
                    if (userData.reasons) {
                        localStorage.setItem(`reasons_${username}`, JSON.stringify(userData.reasons));
                        console.log(`Imported ${Object.keys(userData.reasons).length} reasons for ${username}`);
                    }
                    if (userData.progress) {
                        localStorage.setItem(`progress_${username}`, JSON.stringify(userData.progress));
                    }
                    if (userData.timestamps) {
                        localStorage.setItem(`timestamps_${username}`, JSON.stringify(userData.timestamps));
                    }
                    if (userData.attempts) {
                        localStorage.setItem(`attempts_${username}`, JSON.stringify(userData.attempts));
                    }

                    // CRITICAL: Update classData for both current user AND peer data
                    const classData = JSON.parse(localStorage.getItem('classData') || '{}');
                    if (!classData.users) classData.users = {};

                    // First, ensure current user exists in classData and populate their data
                    if (!classData.users[username]) {
                        classData.users[username] = { answers: {}, reasons: {}, timestamps: {}, attempts: {} };
                    }
                    if (userData.answers) {
                        // STANDARDIZATION FIX: Use migration function for current user too
                        const standardizedAnswers = migrateAnswersToStandardFormat(userData.answers);
                        Object.assign(classData.users[username].answers, standardizedAnswers);
                        // Also update timestamps
                        Object.keys(standardizedAnswers).forEach(qId => {
                            classData.users[username].timestamps[qId] = standardizedAnswers[qId].timestamp;
                        });
                    }
                    if (userData.reasons) Object.assign(classData.users[username].reasons, userData.reasons);
                    if (userData.timestamps) Object.assign(classData.users[username].timestamps, userData.timestamps);
                    if (userData.attempts) Object.assign(classData.users[username].attempts, userData.attempts);
                    console.log(`Updated classData for current user ${username} with ${Object.keys(userData.answers || {}).length} answers (standardized format)`);

                    let peerCount = 0;
                    Object.keys(allStudentsData).forEach(otherUsername => {
                        if (otherUsername !== username) {
                            peerCount++;
                            if (!classData.users[otherUsername]) {
                                classData.users[otherUsername] = { answers: {}, reasons: {}, timestamps: {}, attempts: {} };
                            }

                            const otherUserData = allStudentsData[otherUsername];
                            if (otherUserData.answers) {
                                // STANDARDIZATION FIX: Use consistent object format for peer data too
                                const standardizedAnswers = migrateAnswersToStandardFormat(otherUserData.answers);
                                Object.keys(standardizedAnswers).forEach(questionId => {
                                    const answerObj = standardizedAnswers[questionId];
                                    // Store the full object, not just the value
                                    classData.users[otherUsername].answers[questionId] = answerObj;
                                    // Also store timestamp separately for backward compatibility
                                    classData.users[otherUsername].timestamps[questionId] = answerObj.timestamp;
                                });
                            }
                            if (otherUserData.reasons) {
                                Object.assign(classData.users[otherUsername].reasons, otherUserData.reasons);
                            }
                            if (otherUserData.attempts) {
                                Object.assign(classData.users[otherUsername].attempts, otherUserData.attempts);
                            }
                        }
                    });

                    localStorage.setItem('classData', JSON.stringify(classData));
                    showMessage(`Data imported successfully for ${username}! Found ${peerCount} peer students.`, 'success');
                }

                if (!importSuccess) {
                    throw new Error('Unrecognized file format - check your file structure');
                }

                // Initialize and show welcome, then navigate to units
                showUsernameWelcome();
                initializeFromEmbeddedData();

                // Auto-navigate to units page after successful import
                setTimeout(() => {
                    showMessage(`Successfully imported data for ${username}! Redirecting to units...`, 'success');
                }, 500);

            } catch (error) {
                showMessage('Error importing data: ' + error.message, 'error');
                console.error('Import error:', error);
            }
        }

        // CSV Integration Functions
        let csvMappingData = null;
        let masterDataForCSV = null;

        window.showCSVImportModal = function() {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.id = 'csvImportModal';

            modal.innerHTML = `
                <div class="modal-content">
                    <span class="close-modal" onclick="closeCSVImportModal()">&times;</span>
                    <h3>📊 CSV Import Setup</h3>
                    <p>Import master class data with CSV student mapping</p>

                    <div class="csv-import-steps">
                        <div class="import-step">
                            <h4>Step 1: Select Master Data File</h4>
                            <p>Choose your exported class data (JSON file)</p>
                            <input type="file"
                                   id="masterDataFile"
                                   accept=".json"
                                   onchange="loadMasterDataFile(event)">
                            <div id="masterDataStatus" class="file-status"></div>
                        </div>

                        <div class="import-step">
                            <h4>Step 2: Select CSV Student Roster</h4>
                            <p>Choose CSV file with student names and usernames<br>
                               <small>Format: Student Name, Username (comma-separated)</small></p>
                            <input type="file"
                                   id="csvMappingFile"
                                   accept=".csv"
                                   onchange="loadCSVMappingFile(event)">
                            <div id="csvMappingStatus" class="file-status"></div>
                        </div>

                        <div class="import-step">
                            <h4>Step 3: Select Your Name</h4>
                            <p>Choose your name from the CSV roster</p>
                            <select id="studentNameSelect" disabled>
                                <option value="">Load CSV file first...</option>
                            </select>
                        </div>

                        <div class="csv-import-actions">
                            <button onclick="processCSVImport()"
                                    id="processCSVImportBtn"
                                    class="action-button primary"
                                    disabled>
                                Import Data
                            </button>
                            <button onclick="closeCSVImportModal()"
                                    class="action-button secondary">
                                Cancel
                            </button>
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        window.closeCSVImportModal = function() {
            const modal = document.getElementById('csvImportModal');
            if (modal) {
                modal.remove();
            }
            csvMappingData = null;
            masterDataForCSV = null;
        }

        window.loadMasterDataFile = function(event) {
            console.log('=== loadMasterDataFile called ===');
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    masterDataForCSV = JSON.parse(e.target.result);
                    console.log('Master data loaded:', masterDataForCSV);

                    const studentCount = Object.keys(masterDataForCSV.students || masterDataForCSV.allUsers || {}).length;
                    document.getElementById('masterDataStatus').innerHTML =
                        `<span style="color: green;">✓ Master data loaded (${studentCount} students)</span>`;
                    checkCSVImportReady();
                } catch (error) {
                    document.getElementById('masterDataStatus').innerHTML =
                        `<span style="color: red;">✗ Invalid JSON file</span>`;
                    masterDataForCSV = null;
                }
            };
            reader.readAsText(file);
        }

        // New function to import all peer data directly
        window.importAllPeerData = function() {
            if (!masterDataForCSV) {
                showMessage('No master data loaded', 'error');
                return;
            }

            console.log('=== Importing all peer data ===');
            importMasterData(masterDataForCSV);
            showMessage('✅ All peer data imported successfully!', 'success');
            closeCSVImportModal();
        }

        window.loadCSVMappingFile = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csvText = e.target.result;
                    csvMappingData = parseCSVMapping(csvText);

                    if (csvMappingData && csvMappingData.length > 0) {
                        populateStudentSelect(csvMappingData);
                        document.getElementById('csvMappingStatus').innerHTML =
                            `<span style="color: green;">✓ CSV loaded (${csvMappingData.length} students)</span>`;
                        checkCSVImportReady();
                    } else {
                        document.getElementById('csvMappingStatus').innerHTML =
                            `<span style="color: red;">✗ No student data found. Check CSV format.</span>`;
                    }
                } catch (error) {
                    document.getElementById('csvMappingStatus').innerHTML =
                        `<span style="color: red;">✗ Error reading CSV file</span>`;
                    csvMappingData = null;
                }
            };
            reader.readAsText(file);
        }

        function parseCSVMapping(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length < 1) return null;

            const students = [];
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                // Split by comma and clean up the values
                const parts = line.split(',').map(part => part.trim().replace(/^["']|["']$/g, ''));
                if (parts.length >= 2 && parts[0] && parts[1]) {
                    students.push({
                        name: parts[0],
                        username: parts[1]
                    });
                }
            }

            return students.length > 0 ? students : null;
        }

        function populateStudentSelect(mappingData) {
            const select = document.getElementById('studentNameSelect');
            select.innerHTML = '<option value="">Select your name...</option>';

            mappingData.forEach((student, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = `${student.name} (${student.username})`;
                select.appendChild(option);
            });

            select.disabled = false;
        }

        function checkCSVImportReady() {
            const btn = document.getElementById('processCSVImportBtn');
            if (masterDataForCSV && csvMappingData) {
                btn.disabled = false;
            }
        }

        window.processCSVImport = function() {
            const selectedIndex = document.getElementById('studentNameSelect').value;
            if (!selectedIndex || !csvMappingData || !masterDataForCSV) {
                showMessage('Please complete all steps first', 'error');
                return;
            }

            const selectedStudent = csvMappingData[selectedIndex];
            const username = selectedStudent.username;

            // Save data before closing modal (since closeCSVImportModal clears it)
            const savedMasterData = masterDataForCSV;

            // Close modal
            closeCSVImportModal();

            // Import data for the selected user
            showMessage(`Importing data for ${selectedStudent.name} (${username})...`, 'info');
            importDataForUser(username, savedMasterData);
        }

        // Global ESC Key Handler for All Modals
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                // Find any open modal and close it
                const modals = [
                    'syncModal',
                    'csvImportModal',
                    'userManagementModal'
                ];

                for (const modalId of modals) {
                    const modal = document.getElementById(modalId);
                    if (modal && modal.style.display !== 'none') {
                        // Close the modal using the appropriate close function
                        switch (modalId) {
                            case 'syncModal':
                                if (typeof closeSyncModal === 'function') {
                                    closeSyncModal();
                                } else {
                                    modal.style.display = 'none';
                                }
                                break;
                            case 'csvImportModal':
                                closeCSVImportModal();
                                break;
                            case 'userManagementModal':
                                closeUserManagement();
                                break;
                        }
                        event.preventDefault();
                        break; // Only close one modal at a time
                    }
                }

                // Also check for any generic modals with class 'modal'
                const genericModals = document.querySelectorAll('.modal');
                for (const modal of genericModals) {
                    if (modal.style.display !== 'none' && modal.offsetParent !== null) {
                        // Try to find a close button and click it
                        const closeBtn = modal.querySelector('.close-modal');
                        if (closeBtn) {
                            closeBtn.click();
                            event.preventDefault();
                            break;
                        } else {
                            // Fallback: just hide the modal
                            modal.style.display = 'none';
                            event.preventDefault();
                            break;
                        }
                    }
                }
            }
        });

        // Global Ctrl+S Shortcut Handler
        document.addEventListener('keydown', function(event) {
            if (event.ctrlKey && event.key === 's') {
                // Check if user is typing in an input field
                const activeElement = document.activeElement;
                const isTyping = activeElement && (
                    activeElement.tagName === 'TEXTAREA' ||
                    activeElement.tagName === 'INPUT' ||
                    activeElement.contentEditable === 'true' ||
                    activeElement.classList.contains('frq-textarea') ||
                    activeElement.classList.contains('reason-textarea')
                );

                // Don't trigger if user is typing
                if (isTyping) {
                    return;
                }

                // Prevent browser's default save behavior
                event.preventDefault();

                // Flash green effect
                flashGreenScreen();

                // Open sync modal after flash
                setTimeout(() => {
                    showSyncModal();
                }, 150);
            }
        });

        // Green flash effect function
        function flashGreenScreen() {
            const flash = document.createElement('div');
            flash.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background-color: rgba(76, 175, 80, 0.3);
                z-index: 999999;
                pointer-events: none;
                animation: flashFade 0.3s ease-out;
            `;

            // Add CSS animation if not exists
            if (!document.querySelector('#flashAnimation')) {
                const style = document.createElement('style');
                style.id = 'flashAnimation';
                style.textContent = `
                    @keyframes flashFade {
                        0% { opacity: 0; }
                        50% { opacity: 1; }
                        100% { opacity: 0; }
                    }
                `;
                document.head.appendChild(style);
            }

            document.body.appendChild(flash);

            // Remove flash after animation
            setTimeout(() => {
                if (flash.parentNode) {
                    flash.parentNode.removeChild(flash);
                }
            }, 300);
        }

        // Unified Sync Modal System

        window.closeSyncModal = function() {
            const modal = document.getElementById('unifiedSyncModal');
            if (modal) {
                modal.remove();
            }
        }



        // Call this function whenever currentUsername changes
        function updateCurrentUsernameDisplay() {
            // Reinitialize pig sprite with user's saved color
            if (typeof initializePigSprite === 'function') {
                initializePigSprite();
            }
        }

        // Function to load recently used usernames
        function loadRecentUsernames() {
            const recentUsers = [];

            // Check localStorage for any stored usernames
            for (let key in localStorage) {
                if (key.startsWith('answers_')) {
                    const username = key.replace('answers_', '');
                    if (username && username !== 'undefined') {
                        recentUsers.push(username);
                    }
                }
            }

            // Also check class data
            const classData = JSON.parse(localStorage.getItem('classData') || '{}');
            if (classData.users) {
                Object.keys(classData.users).forEach(u => {
                    if (!recentUsers.includes(u)) {
                        recentUsers.push(u);
                    }
                });
            }

            // Display recent usernames if any found
            if (recentUsers.length > 0) {
                const container = document.getElementById('recentUsernames');
                const list = document.getElementById('recentUsernamesList');

                container.style.display = 'block';
                list.innerHTML = recentUsers.map(u => `
                    <button onclick="checkExistingData('${u}')" class="recent-username-btn">
                        ${u}
                    </button>
                `).join('');
            }
        }


        // Enhanced acceptUsername to save to recent list
        const originalAcceptUsername = window.acceptUsername;
        window.acceptUsername = function(name) {
            // Save to recent usernames list
            let recentUsernames = JSON.parse(localStorage.getItem('recentUsernames') || '[]');
            if (!recentUsernames.includes(name)) {
                recentUsernames.unshift(name);
                // Keep only last 5 usernames
                recentUsernames = recentUsernames.slice(0, 5);
                localStorage.setItem('recentUsernames', JSON.stringify(recentUsernames));
            }

            // Call original function
            originalAcceptUsername(name);
        }

        // Function to export username with a simple format
        window.exportUsername = function() {
            if (!currentUsername) {
                showMessage('No username to export', 'error');
                return;
            }

            const exportData = {
                username: currentUsername,
                exportDate: new Date().toISOString(),
                version: '1.0'
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${currentUsername}_identity.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showMessage('Username exported successfully!', 'success');
        }

        function showUsernameWelcome() {
            const container = document.querySelector('.container');
            if (!container) return;
            const existingWelcome = document.querySelector('.username-welcome');
            if (existingWelcome) existingWelcome.remove();

            const welcomeDiv = document.createElement('div');
            welcomeDiv.className = 'username-welcome';
            welcomeDiv.textContent = `Welcome ${currentUsername}!`;
            container.insertBefore(welcomeDiv, container.firstChild.nextSibling);
        }

        function initializeFromEmbeddedData() {
            // Parse embedded curriculum
            allCurriculumData = {};
            const allQuestions = EMBEDDED_CURRICULUM.questions || EMBEDDED_CURRICULUM;

            // Group by units
            const unitGroups = {};
            allQuestions.forEach(question => {
                const unitMatch = question.id.match(/U(\d+)/i);
                if (unitMatch) {
                    const unitNum = parseInt(unitMatch[1]);
                    if (!unitGroups[unitNum]) {
                        unitGroups[unitNum] = [];
                    }
                    unitGroups[unitNum].push(question);
                }
            });

            // Process each unit
            Object.keys(unitGroups).forEach(unitNum => {
                const unitQuestions = unitGroups[unitNum];
                const unitInfo = detectUnitAndLessons(unitQuestions);
                if (unitInfo) {
                    allCurriculumData[unitNum] = {
                        questions: unitQuestions,
                        unitInfo: unitInfo,
                        fileName: `Unit ${unitNum}`
                    };
                }
            });

            // Go straight to unit menu
            renderUnitMenu();
        }

        // Unit selector - REMOVED: No longer needed due to CORS issues
        // function renderUnitSelector() {
        //     const questionsContainer = document.getElementById('questionsContainer');
        //     let buttonsHtml = '';
        //
        //     for (let unitNum in unitStructure) {
        //         const unit = unitStructure[unitNum];
        //         buttonsHtml += `
        //             <button onclick="loadUnit(${unitNum})" class="unit-btn" id="unit-btn-${unitNum}">
        //                 <strong>Unit ${unitNum}</strong><br>
        //                 ${unit.name}
        //             </button>
        //         `;
        //     }
        //
        //     questionsContainer.innerHTML = `
        //         <div class="unit-selector">
        //             <h2>Select a Unit</h2>
        //             <div class="unit-buttons">
        //                 ${buttonsHtml}
        //             </div>
        //         </div>
        //     `;
        // }

        // Load unit
        window.loadUnit = async function(unitNumber) {
            const btn = document.getElementById(`unit-btn-${unitNumber}`);
            if (btn) {
                btn.classList.add('loading');
                btn.disabled = true;
            }

            try {
                const response = await fetch(`unit${unitNumber}.json`);
                if (!response.ok) {
                    throw new Error(`Unit ${unitNumber} file not found`);
                }
                const data = await response.json();
                currentUnit = unitNumber;
                allUnitQuestions = Array.isArray(data) ? data : (data.questions || []);
                
                renderLessonSelector();
                showMessage(`Unit ${unitNumber} loaded successfully!`, 'success');
            } catch (error) {
                showMessage(`Error loading Unit ${unitNumber}: ${error.message}`, 'error');
                if (btn) {
                    btn.classList.remove('loading');
                    btn.disabled = false;
                }
            }
        }

        // Render lesson selector
function renderLessonSelector(unitInfo) {
    const questionsContainer = document.getElementById('questionsContainer');
    
    // If unitInfo provided (from file load), use it
    if (unitInfo && unitInfo.lessonNumbers) {
        let lessonButtonsHtml = '';
        
        unitInfo.lessonNumbers.forEach(lessonNum => {
            const questions = unitInfo.lessons[lessonNum];
            const isCompleted = questions.every(q => isQuestionAnswered(q.id));
            const displayName = lessonNum === 'PC' ? 'Progress Check' : `Lesson ${lessonNum}`;
            const buttonId = lessonNum === 'PC' ? 'lesson-btn-PC' : `lesson-btn-${lessonNum}`;

            lessonButtonsHtml += `
                <button onclick="loadLesson('${lessonNum}')"
                        class="lesson-btn ${isCompleted ? 'completed' : ''}"
                        id="${buttonId}">
                    ${displayName}<br>
                    <small>${questions.length} questions</small>
                </button>
            `;
        });
        
        questionsContainer.innerHTML = `
            <button onclick="backToUnits()" class="back-button">← Back to Units</button>
            <div class="lesson-selector">
                <h3>Unit ${currentUnit}: ${unitStructure[currentUnit]?.name || 'Unknown Unit'}</h3>
                <p>Select a lesson to begin:</p>
                <div class="lesson-buttons">
                    ${lessonButtonsHtml}
                </div>
            </div>
        `;
        return;
    }
    
    // Old fallback code for when called without unitInfo
    const unit = unitStructure[currentUnit];
    if (!unit) return;
    
    let lessonButtonsHtml = '';
    
    // Group questions by lesson
    const lessonGroups = {};
    allUnitQuestions.forEach(q => {
        const match = q.id.match(/L(\d+)/);
        if (match) {
            const lessonNum = parseInt(match[1]);
            if (!lessonGroups[lessonNum]) {
                lessonGroups[lessonNum] = [];
            }
            lessonGroups[lessonNum].push(q);
        }
    });
    
    for (let i = 1; i <= unit.lessons; i++) {
        const questionCount = lessonGroups[i] ? lessonGroups[i].length : 0;
        const isCompleted = checkLessonCompleted(currentUnit, i);
        lessonButtonsHtml += `
            <button onclick="loadLesson(${i})" class="lesson-btn ${isCompleted ? 'completed' : ''}" id="lesson-btn-${i}">
                Lesson ${i}<br>
                <small>${questionCount} questions</small>
            </button>
        `;
    }
    
    questionsContainer.innerHTML = `
        <button onclick="backToUnits()" class="back-button">← Back to Units</button>
        <div class="lesson-selector">
            <h3>Unit ${currentUnit}: ${unit.name}</h3>
            <p>Select a lesson to begin:</p>
            <div class="lesson-buttons">
                ${lessonButtonsHtml}
            </div>
        </div>
    `;
}

        // Check if lesson is completed
        function checkLessonCompleted(unitNum, lessonNum) {
            const lessonQuestions = allUnitQuestions.filter(q => {
                const match = q.id.match(/L(\d+)/);
                return match && parseInt(match[1]) === lessonNum;
            });
            
            if (lessonQuestions.length === 0) return false;
            
            return lessonQuestions.every(q => isQuestionAnswered(q.id));
        }

        // Load lesson
        window.loadLesson = function(lessonNumber) {
            currentLesson = lessonNumber;

            // Handle both numeric lessons and 'PC'
            if (lessonNumber === 'PC') {
                currentQuestions = allUnitQuestions.filter(q => q.id.includes('-PC-'));
            } else {
                const lessonNum = parseInt(lessonNumber);
                currentQuestions = allUnitQuestions.filter(q => {
                    if (q.id.includes('-PC-')) return false; // Exclude PC questions
                    const match = q.id.match(/U\d+-L(\d+)-/);
                    return match && parseInt(match[1]) === lessonNum;
                });
            }

            if (currentQuestions.length === 0) {
                showMessage(`No questions found for Lesson ${lessonNumber}`, 'error');
                return;
            }

            console.log(`Loading lesson ${lessonNumber} with ${currentQuestions.length} questions`); // Debug
            renderQuiz();
        }

        // Back to units
        window.backToUnits = function() {
            // Clear any existing charts
            Object.values(chartInstances).forEach(chart => {
                if (chart && typeof chart.destroy === 'function') {
                    chart.destroy();
                }
            });
            chartInstances = {};
            currentQuestions = [];
            allUnitQuestions = [];
            currentUnit = null;
            currentLesson = null;

            // Go to unit menu
            renderUnitMenu();
        }

        // Back to lessons
        window.backToLessons = function() {
            // Clear any existing charts
            Object.values(chartInstances).forEach(chart => {
                if (chart && typeof chart.destroy === 'function') {
                    chart.destroy();
                }
            });
            chartInstances = {};
            currentQuestions = [];
            currentLesson = null;

            // Re-detect the unit structure from allUnitQuestions
            const unitInfo = detectUnitAndLessons(allUnitQuestions);

            // Call renderLessonSelector with the unitInfo
            renderLessonSelector(unitInfo);
        }

        // Render quiz
        function renderQuiz() {
            const questionsContainer = document.getElementById('questionsContainer');
            
            questionsContainer.innerHTML = `
                <button onclick="backToLessons()" class="back-button">← Back to Lessons</button>
                <div class="app-controls">
                    <div style="flex: 1;">
                        <strong>Unit ${currentUnit}, Lesson ${currentLesson}</strong> - ${currentQuestions.length} questions
                    </div>
                </div>

                <div id="questions-list"></div>
                <div class="loading-msg" id="loading-msg" style="display:none;">Loading questions...</div>
            `;
            
            const questionsList = document.getElementById('questions-list');
            
            // Show loading message
            document.getElementById('loading-msg').style.display = 'block';
            
            // Render all questions for the lesson with a small delay for animation
            setTimeout(() => {
                currentQuestions.forEach((question, index) => {
                    const questionHtml = renderQuestion(question, index);
                    questionsList.insertAdjacentHTML('beforeend', questionHtml);
                });
                
                document.getElementById('loading-msg').style.display = 'none';
                
                // Load saved progress
                loadProgress();
                
                // Render MathJax
                if (window.MathJax) {
                    MathJax.typesetPromise().catch(e => console.log('MathJax error:', e));
                }
                
                // Render charts for visible questions
                setTimeout(renderVisibleCharts, 100);
            }, 100);
        }

        // Render question
        function renderQuestion(question, index) {
            const questionNumber = index + 1;
            const isAnswered = isQuestionAnswered(question.id);
            const attempts = getAttemptCount(question.id);
            const canRetryQuestion = canRetry(question.id);

            // Check if answer is correct (for styling)
            let isCorrect = false;
            if (isAnswered) {
                const correctAnswer = getCorrectAnswer(question.id);
                const userAnswer = classData.users[currentUsername]?.answers?.[question.id];
                const userAnswerValue = userAnswer?.value || userAnswer;
                if (correctAnswer && userAnswerValue) {
                    isCorrect = (userAnswerValue.toString().toLowerCase().trim() === correctAnswer.toString().toLowerCase().trim());
                }
            }

            // Create two-column layout structure
            let html = `
                <div class="quiz-container two-column-layout" data-question-id="${question.id}" data-question-number="${questionNumber}">
                    <div class="question-main-column">
                        <div class="question-header ${isCorrect ? 'correct-answer' : ''}">
                            <span>Question ${questionNumber}</span>
                            ${isAnswered ? (isCorrect ? '<span style="color: #f39c12;">⭐ Correctly Answered</span>' : '<span style="color: #a5d6a7;">✓ Answered</span>') : ''}
                        </div>
                        <div class="question-id">ID: ${question.id || 'N/A'}</div>
                        <div class="question-prompt">${question.prompt || 'No prompt provided'}</div>
            `;

            // Render question attachments (charts, tables, images) in main column
            if (question.attachments) {
                html += renderAttachments(question.attachments, question.id);
            }

            // Handle MCQ in main column
            if (question.type === 'multiple-choice') {
                const choices = question.choices || question.attachments?.choices || [];
                const savedAnswer = classData.users[currentUsername]?.answers?.[question.id];
                const isDisabled = isAnswered && !canRetryQuestion;

                html += '<div class="choices">';
                choices.forEach(choice => {
                    const isSelected = savedAnswer?.value === choice.key || savedAnswer === choice.key;
                    html += `
                        <div class="choice ${isSelected ? 'selected' : ''} ${isDisabled ? 'disabled' : ''}">
                            <label>
                                <input type="radio"
                                       name="choice-${question.id}"
                                       value="${choice.key}"
                                       ${isSelected ? 'checked' : ''}
                                       ${isDisabled ? 'disabled' : ''}>
                                <span class="choice-key">${choice.key}.</span>
                                <span>${choice.value}</span>
                            </label>
                        </div>
                    `;
                });
                html += '</div>';
            }

            // Handle FRQ in main column
            if (question.type === 'free-response') {
                const savedAnswer = classData.users[currentUsername]?.answers?.[question.id];
                const isDisabled = isAnswered && !canRetryQuestion;
                html += `
                    <div class="answer-section">
                        <textarea
                            id="frq-${question.id}"
                            class="frq-textarea"
                            placeholder="Enter your complete response here..."
                            ${isDisabled ? 'disabled' : ''}
                            style="width: 100%; min-height: 200px; padding: 10px; border: 2px solid #ddd;"
                        >${savedAnswer?.value || savedAnswer || ''}</textarea>
                    </div>
                `;
            }

            // Add reasoning section in main column
            html += `
                        <div class="answer-section">
                            <div class="reason-wrapper">
                                <label class="reason-label">
                                    ${attempts > 0 && !canRetryQuestion ?
                                        'Your explanation (required for retry):' :
                                        'Explain your reasoning (optional but enables retry):'}
                                </label>
                                <textarea
                                    id="reason-${question.id}"
                                    class="reason-textarea ${attempts > 0 && canRetryQuestion ? 'required' : ''}"
                                    placeholder="${attempts > 0 && !canRetryQuestion ?
                                        'Previous attempt did not include reasoning. Add reasoning to enable retry.' :
                                        'Explain why you chose this answer...'}"
                                    ${!canRetryQuestion && attempts >= 3 ? 'disabled' : ''}
                                >${classData.users[currentUsername]?.reasons?.[question.id] || ''}</textarea>
                            </div>
                            <div>
                                <button
                                    id="submit-${question.id}"
                                    class="submit-button"
                                    onclick="submitAnswer('${question.id}', '${question.type}')"
                                    ${!canRetryQuestion && isAnswered ? 'disabled' : ''}
                                >
                                    ${isAnswered ? (canRetryQuestion ? 'Update Answer' : 'Max Attempts Reached') : 'Submit Answer'}
                                </button>

                                ${isAnswered && !canRetryQuestion && attempts < 3 && !(classData.users[currentUsername]?.reasons?.[question.id]?.trim()) ? `
                                    <button
                                        id="add-explanation-${question.id}"
                                        class="add-explanation-button"
                                        onclick="addExplanationToRetry('${question.id}')"
                                        style="margin-left: 10px; background: #28a745; color: white;"
                                    >
                                        Add Explanation to Retry
                                    </button>
                                ` : ''}

                                <span id="error-${question.id}" class="error-msg"></span>
                                <span id="success-${question.id}" class="success-msg"></span>
                            </div>
                        </div>
                    </div>

                    <!-- RIGHT COLUMN: Peer Reasoning Sidebar -->
                    <div class="peer-sidebar">
                        <div class="peer-sidebar-content">
                            <!-- Peer reasoning section (main focus) -->
                            <div class="peer-reasoning-section" id="peer-reasoning-${question.id}">
                                <div class="peer-reasoning-header">
                                    <h4>🤝 Peer Responses</h4>
                                    <span class="peer-count" id="peer-count-${question.id}">Loading...</span>
                                </div>
                                <div class="peer-reasoning-content" id="peer-reasoning-content-${question.id}">
                                    ${isAnswered ? '<div class="peer-loading">Loading peer responses...</div>' : '<div class="peer-hint">Answer the question to see peer responses</div>'}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // If this question is already answered, populate peer responses immediately
            setTimeout(() => {
                if (isAnswered) {
                    populatePeerResponses(question.id, question.type);

                    // Check if answer was correct and should show College Board explanation
                    const userAnswer = classData.users[currentUsername]?.answers?.[question.id];
                    const userReason = classData.users[currentUsername]?.reasons?.[question.id];
                    const correctAnswer = getCorrectAnswer(question.id);

                    if (userAnswer && correctAnswer) {
                        const userValue = userAnswer.value || userAnswer;
                        const isCorrect = (userValue.toString().toLowerCase().trim() === correctAnswer.toString().toLowerCase().trim());
                        const hasExplanation = (userReason && userReason.trim().length > 0);

                        console.log(`DEBUG: On load - isCorrect: ${isCorrect}, hasExplanation: ${hasExplanation}`);

                        // Show College Board explanation if conditions are met
                        if (isCorrect && hasExplanation) {
                            displayCollegeBoardExplanation(question.id);
                            // Also change textarea border to gold
                            const reasonTextarea = document.getElementById(`reason-${question.id}`);
                            if (reasonTextarea) {
                                reasonTextarea.style.borderColor = '#f39c12';
                                reasonTextarea.style.boxShadow = '0 0 0 0.2rem rgba(243, 156, 18, 0.25)';
                            }
                        }
                    }
                }
            }, 100);

            return html;
        }

        // Populate peer reasoning section with peer response cards
        function populatePeerReasoning(questionId, contributors) {
            const peerReasoningContent = document.getElementById(`peer-reasoning-content-${questionId}`);
            const peerCountSpan = document.getElementById(`peer-count-${questionId}`);

            if (!peerReasoningContent) return;

            // Filter out current user's responses for peer display
            const peerResponses = contributors.filter(c => c.username !== currentUsername);

            // Update peer count
            if (peerCountSpan) {
                peerCountSpan.textContent = peerResponses.length > 0 ? `${peerResponses.length} peers` : 'No peers yet';
            }

            if (peerResponses.length === 0) {
                peerReasoningContent.innerHTML = '<div class="peer-hint">No peer responses yet. Be the first to answer!</div>';
                return;
            }

            // Sort responses - those with reasoning first
            peerResponses.sort((a, b) => {
                const aHasReason = a.reason && a.reason.trim().length > 0;
                const bHasReason = b.reason && b.reason.trim().length > 0;
                if (aHasReason && !bHasReason) return -1;
                if (!aHasReason && bHasReason) return 1;
                return 0;
            });

            // Check if answer key has been revealed for this question
            const answerKeySection = document.getElementById(`answer-key-${questionId}`);
            const cbSection = document.getElementById(`college-board-explanation-${questionId}`);
            const answerKeyRevealed = (answerKeySection && answerKeySection.style.display === 'block') ||
                                    (cbSection && cbSection.style.display === 'block');

            console.log(`DEBUG populatePeerReasoning: ${questionId} - answerKeySection exists: ${!!answerKeySection}, cbSection exists: ${!!cbSection}`);
            console.log(`DEBUG populatePeerReasoning: ${questionId} - answerKeyRevealed: ${answerKeyRevealed}`);

            let html = '';
            peerResponses.forEach(peer => {
                const hasReason = peer.reason && peer.reason.trim().length > 0;

                // Determine if this peer's answer is correct (only if answer key is revealed)
                let isCorrect = false;
                const isCollegeBoard = peer.username === 'college_board';

                if (answerKeyRevealed || isCollegeBoard) {
                    const correctAnswer = getCorrectAnswer(questionId);
                    if (correctAnswer && (peer.choice || peer.response)) {
                        const peerAnswer = peer.choice || peer.response;
                        isCorrect = (peerAnswer.toString().toLowerCase().trim() === correctAnswer.toString().toLowerCase().trim());
                    }
                }

                console.log(`DEBUG: Peer ${peer.username} - answer: ${peer.choice || peer.response}, isCorrect: ${isCorrect}, answerKeyRevealed: ${answerKeyRevealed}`);

                html += `
                    <div class="peer-response-card ${isCorrect ? 'correct' : 'incorrect'} ${isCollegeBoard ? 'college-board-official' : ''}">
                        <div class="peer-name">
                            ${isCollegeBoard ? '🏛️ College Board (Official)' : peer.username}
                            ${isCorrect || isCollegeBoard ? '✓' : ''}
                        </div>
                        <div class="peer-answer"><strong>Answer:</strong> ${peer.choice || peer.response}</div>
                        ${hasReason ? `
                            <div class="peer-reasoning-text ${isCollegeBoard ? 'official-explanation' : ''}">${peer.reason}</div>
                        ` : '<div class="peer-reasoning-text" style="color: #999; font-style: italic;">No explanation provided</div>'}

                        ${peer.response && !isCollegeBoard ? `
                            <div class="peer-voting-buttons" style="margin-top: 10px;">
                                <button onclick="voteFRQ('${questionId}', '${peer.username}', 'helpful')" class="vote-btn helpful">
                                    💡 Helpful (${getVoteCount(questionId, peer.username, 'helpful')})
                                </button>
                                <button onclick="voteFRQ('${questionId}', '${peer.username}', 'unclear')" class="vote-btn unclear">
                                    🤔 Unclear (${getVoteCount(questionId, peer.username, 'unclear')})
                                </button>
                                <button onclick="voteFRQ('${questionId}', '${peer.username}', 'contradicts')" class="vote-btn contradicts">
                                    ⚔️ Contradicts (${getVoteCount(questionId, peer.username, 'contradicts')})
                                </button>
                            </div>
                        ` : ''}
                    </div>
                `;
            });

            peerReasoningContent.innerHTML = html;
        }

        // Gather peer responses and populate reasoning section
        function populatePeerResponses(questionId, questionType) {
            const contributors = [];

            // Gather all user responses for this question
            for (let username in classData.users) {
                const userAnswer = classData.users[username].answers?.[questionId];
                if (userAnswer) {
                    const response = userAnswer.value || userAnswer;
                    const reason = classData.users[username].reasons?.[questionId] || '';

                    if (questionType === 'multiple-choice') {
                        contributors.push({
                            username: username,
                            choice: response,
                            reason: reason
                        });
                    } else {
                        // FRQ
                        contributors.push({
                            username: username,
                            response: response,
                            reason: reason
                        });
                    }
                }
            }

            // Call the populate function with the gathered data
            populatePeerReasoning(questionId, contributors);
        }

        // Render attachments (charts, tables, images)
        function renderAttachments(attachments, questionId) {
            let html = '';

            // Handle charts
            if (attachments.chartType) {
                html += renderChart(attachments, questionId);
            }

            // Handle tables
            if (attachments.table) {
                html += renderTable(attachments.table);
            }

            // Handle images
            if (attachments.image) {
                html += `
                    <div class="image-container">
                        <img src="${attachments.image}" alt="Question image" style="max-width: 100%; height: auto;">
                    </div>
                `;
            }

            return html;
        }

        // Render attachments for sidebar (with modified sizing)
        function renderAttachmentsForSidebar(attachments, questionId) {
            let html = '';

            // Handle charts in sidebar
            if (attachments.chartType) {
                html += `
                    <div class="sidebar-chart-container">
                        <h5>📊 Data Visualization</h5>
                        ${renderChart(attachments, questionId + '-sidebar')}
                    </div>
                `;
            }

            // Handle tables in sidebar
            if (attachments.table) {
                html += `
                    <div class="sidebar-table-container">
                        <h5>📋 Data Table</h5>
                        ${renderTable(attachments.table)}
                    </div>
                `;
            }

            // Handle images in sidebar
            if (attachments.image) {
                html += `
                    <div class="sidebar-image-container">
                        <h5>🖼️ Reference Image</h5>
                        <img src="${attachments.image}" alt="Question image" style="max-width: 100%; height: auto; border-radius: 8px;">
                    </div>
                `;
            }

            return html;
        }
        
        // Render chart placeholder (actual rendering happens later)
          // FIXED: Table rendering to handle both object and array formats
          function renderTable(table) {
              if (!table) return '';

              let tableHtml = '<div class="table-container"><table>';

              // Handle object format (with headers and rows properties)
              if (table.headers && table.rows) {
                  // Render headers
                  tableHtml += '<thead><tr>';
                  table.headers.forEach(header => {
                      tableHtml += `<th>${header}</th>`;
                  });
                  tableHtml += '</tr></thead>';

                  // Render rows
                  if (table.rows && table.rows.length > 0) {
                      tableHtml += '<tbody>';
                      table.rows.forEach(row => {
                          tableHtml += '<tr>';
                          row.forEach(cell => {
                              tableHtml += `<td>${cell}</td>`;
                          });
                          tableHtml += '</tr>';
                      });
                      tableHtml += '</tbody>';
                  }
              }
              // Handle array format (legacy)
              else if (Array.isArray(table) && table.length > 0) {
                  const headers = table[0];
                  const rows = table.slice(1);

                  // Headers
                  tableHtml += '<thead><tr>';
                  headers.forEach(header => {
                      tableHtml += `<th>${header}</th>`;
                  });
                  tableHtml += '</tr></thead>';

                  // Rows
                  if (rows.length > 0) {
                      tableHtml += '<tbody>';
                      rows.forEach(row => {
                          tableHtml += '<tr>';
                          row.forEach(cell => {
                              tableHtml += `<td>${cell}</td>`;
                          });
                          tableHtml += '</tr>';
                      });
                      tableHtml += '</tbody>';
                  }
              }

              tableHtml += '</table></div>';

              return tableHtml;
          }
// Complete chart rendering function
function renderChartNow(chartId) {
    const canvas = document.getElementById(chartId);
    if (!canvas) return;

    // FIX: Check if chart already exists and destroy it
    if (chartInstances[chartId]) {
        chartInstances[chartId].destroy();
        delete chartInstances[chartId];
    }

    const chartData = window.pendingCharts[chartId];
    if (!chartData) return;

    const ctx = canvas.getContext('2d');

    // FIX: Set canvas parent height to prevent infinite expansion
    canvas.parentElement.style.height = '400px';
    canvas.parentElement.style.position = 'relative';

    const config = chartData.chartConfig || {};
    
    // Bar/Histogram charts
    if (chartData.chartType === 'bar' || chartData.chartType === 'histogram') {
        const colorPalette = ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40'];
        const datasets = chartData.series.map((series, index) => ({
            label: series.name,
            data: series.values,
            backgroundColor: colorPalette[index % colorPalette.length],
            borderColor: colorPalette[index % colorPalette.length],
            borderWidth: 1
        }));
        
        const isHistogram = chartData.chartType === 'histogram';
        
        chartInstances[chartId] = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: chartData.xLabels || [],
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: datasets.length > 1
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        min: config.yAxis?.min,
                        max: config.yAxis?.max,
                        title: {
                            display: true,
                            text: config.yAxis?.title || chartData.yLabel || 'Value'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: config.xAxis?.title || chartData.xLabel || 'Category'
                        }
                    }
                }
            }
        });
    }
    
    // Pie chart
    else if (chartData.chartType === 'pie') {
        const seriesData = chartData.series[0].values;
        const labels = seriesData.map(item => item.name);
        const values = seriesData.map(item => item.value);
        
        chartInstances[chartId] = new Chart(ctx, {
            type: 'pie',
            data: {
                labels: labels,
                datasets: [{
                    data: values,
                    backgroundColor: ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF'],
                    borderWidth: 2,
                    borderColor: '#fff'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'bottom'
                    }
                }
            }
        });
    }
    
    // Scatter plot
    else if (chartData.chartType === 'scatter') {
        chartInstances[chartId] = new Chart(ctx, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'Data Points',
                    data: chartData.points,
                    backgroundColor: '#36A2EB',
                    borderColor: '#36A2EB',
                    pointRadius: 4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'linear',
                        position: 'bottom',
                        min: config.xAxis?.min,
                        max: config.xAxis?.max,
                        title: {
                            display: true,
                            text: config.xAxis?.title || chartData.xLabel || 'X Variable'
                        }
                    },
                    y: {
                        min: config.yAxis?.min,
                        max: config.yAxis?.max,
                        title: {
                            display: true,
                            text: config.yAxis?.title || chartData.yLabel || 'Y Variable'
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    }
                }
            }
        });
    }
    
    // Dotplot
    else if (chartData.chartType === 'dotplot') {
        const valueFrequency = {};
        chartData.values.forEach(value => {
            valueFrequency[value] = (valueFrequency[value] || 0) + 1;
        });
        
        const dotplotData = [];
        for (const [value, frequency] of Object.entries(valueFrequency)) {
            for (let i = 1; i <= frequency; i++) {
                dotplotData.push({
                    x: parseFloat(value),
                    y: i
                });
            }
        }
        
        chartInstances[chartId] = new Chart(ctx, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'Data Points',
                    data: dotplotData,
                    backgroundColor: '#36A2EB',
                    borderColor: '#36A2EB',
                    pointRadius: 4,
                    showLine: false
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'linear',
                        min: config.xAxis?.min,
                        max: config.xAxis?.max,
                        title: {
                            display: true,
                            text: config.xAxis?.title || 'Value'
                        }
                    },
                    y: {
                        min: 0,
                        max: Math.max(...Object.values(valueFrequency)) + 1,
                        display: false
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    }
                }
            }
        });
    }
    
    // Boxplot
    else if (chartData.chartType === 'boxplot') {
        const boxplotData = config.boxplotData || {};
        const { Q1, Q3, median, min, max } = boxplotData;
        
        // Create a simple representation using bar chart
        chartInstances[chartId] = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: ['Min', 'Q1', 'Median', 'Q3', 'Max'],
                datasets: [{
                    label: 'Five Number Summary',
                    data: [min, Q1, median, Q3, max],
                    backgroundColor: '#36A2EB'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: false,
                        title: {
                            display: true,
                            text: config.xAxis?.title || 'Value'
                        }
                    }
                }
            }
        });
    }
}

// Complete table rendering
function renderTable(table) {
    if (!table) return '';
    
    let html = '<div class="table-container"><table>';
    
    // Handle object format with headers and rows
    if (table.headers && table.rows) {
        html += '<thead><tr>';
        table.headers.forEach(header => {
            html += `<th>${header}</th>`;
        });
        html += '</tr></thead><tbody>';
        
        table.rows.forEach(row => {
            html += '<tr>';
            row.forEach(cell => {
                html += `<td>${cell}</td>`;
            });
            html += '</tr>';
        });
        html += '</tbody>';
    }
    // Handle array format (legacy)
    else if (Array.isArray(table) && table.length > 0) {
        const headers = table[0];
        const rows = table.slice(1);
        
        html += '<thead><tr>';
        headers.forEach(header => {
            html += `<th>${header}</th>`;
        });
        html += '</tr></thead>';
        
        if (rows.length > 0) {
            html += '<tbody>';
            rows.forEach(row => {
                html += '<tr>';
                row.forEach(cell => {
                    html += `<td>${cell}</td>`;
                });
                html += '</tr>';
            });
            html += '</tbody>';
        }
    }
    
    html += '</table></div>';
    return html;
}

// Updated renderAttachments to handle multiple charts
function renderAttachments(attachments, questionId) {
    let html = '';
    
    // Handle multiple charts
    if (attachments.charts && Array.isArray(attachments.charts)) {
        attachments.charts.forEach((chart, idx) => {
            html += renderChart(chart, `${questionId}-chart-${idx}`);
        });
    }
    // Handle single chart
    else if (attachments.chartType) {
        html += renderChart(attachments, `${questionId}-chart`);
    }
    
    // Handle tables
    if (attachments.table) {
        html += renderTable(attachments.table);
    }
    
    // Handle images
    if (attachments.image) {
        const imageAlt = attachments.imageAlt || 'Question image';
        const imageCaption = attachments.imageCaption || '';
        html += `
            <div class="image-container">
                <img src="${attachments.image}" alt="${imageAlt}" style="max-width: 100%; height: auto;">
                ${imageCaption ? `<div style="text-align: center; font-style: italic; color: #666; margin-top: 5px;">${imageCaption}</div>` : ''}
            </div>
        `;
    }
    
    // Handle multiple images
    if (attachments.images && Array.isArray(attachments.images)) {
        html += '<div style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;">';
        attachments.images.forEach(img => {
            html += `
                <div style="flex: 1; min-width: 200px; max-width: 400px;">
                    <img src="${img.url || img}" alt="${img.alt || 'Image'}" style="width: 100%; height: auto;">
                    ${img.caption ? `<div style="text-align: center; font-style: italic; color: #666; margin-top: 5px;">${img.caption}</div>` : ''}
                </div>
            `;
        });
        html += '</div>';
    }
    
    return html;
}

        // Render visible charts
        function renderVisibleCharts() {
            const chartContainers = document.querySelectorAll('[data-chart-id]');
            chartContainers.forEach(container => {
                const chartId = container.dataset.chartId;
                if (window.pendingCharts && window.pendingCharts[chartId]) {
                    renderChartNow(chartId);
                    delete window.pendingCharts[chartId];
                }
            });
        }

        // Actually render a chart
        function renderChartNow(chartId) {
            const canvas = document.getElementById(chartId);
            if (!canvas) return;

            // FIX: Check if chart already exists and destroy it
            if (chartInstances[chartId]) {
                chartInstances[chartId].destroy();
                delete chartInstances[chartId];
            }

            const chartData = window.pendingCharts[chartId];
            if (!chartData) return;

            const ctx = canvas.getContext('2d');

            // FIX: Set canvas parent height to prevent infinite expansion
            canvas.parentElement.style.height = '400px';
            canvas.parentElement.style.position = 'relative';

            const config = chartData.chartConfig || {};
            
            // Simple bar/histogram chart
            if (chartData.chartType === 'bar' || chartData.chartType === 'histogram') {
                const datasets = chartData.series.map(series => ({
                    label: series.name,
                    data: series.values,
                    backgroundColor: '#36A2EB',
                    borderColor: '#36A2EB',
                    borderWidth: 1
                }));
                
                chartInstances[chartId] = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: chartData.xLabels || [],
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: config.yAxis?.title || 'Value'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: config.xAxis?.title || 'Category'
                                }
                            }
                        }
                    }
                });
            }
            // Add other chart types as needed
        }

        // Submit answer
        window.submitAnswer = function(questionId, questionType) {
            if (!currentUsername) {
                showMessage('Please enter your username first!', 'error');
                return;
            }

            const errorSpan = document.getElementById(`error-${questionId}`);
            const successSpan = document.getElementById(`success-${questionId}`);
            
            // Clear previous messages
            if (errorSpan) {
                errorSpan.textContent = '';
                errorSpan.classList.remove('show');
            }
            if (successSpan) {
                successSpan.textContent = '';
                successSpan.classList.remove('show');
            }

            // Get current attempt count
            const attempts = getAttemptCount(questionId);
            
            // Check if can retry
            if (attempts > 0 && !canRetry(questionId)) {
                if (errorSpan) {
                    errorSpan.textContent = attempts >= 3 ? 
                        'Maximum attempts reached (3).' : 
                        'Please provide reasoning with your previous answer to enable retry.';
                    errorSpan.classList.add('show');
                }
                return;
            }

            // Get answer value
            let value = '';
            if (questionType === 'multiple-choice') {
                const selectedRadio = document.querySelector(`input[name="choice-${questionId}"]:checked`);
                if (!selectedRadio) {
                    if (errorSpan) {
                        errorSpan.textContent = 'Please select an answer.';
                        errorSpan.classList.add('show');
                    }
                    return;
                }
                value = selectedRadio.value;
            } else {
                const textarea = document.getElementById(`frq-${questionId}`);
                if (!textarea || !textarea.value.trim()) {
                    if (errorSpan) {
                        errorSpan.textContent = 'Please enter a response.';
                        errorSpan.classList.add('show');
                    }
                    return;
                }
                value = textarea.value.trim();
            }

            // Get reason
            const reasonTextarea = document.getElementById(`reason-${questionId}`);
            const reason = reasonTextarea ? reasonTextarea.value.trim() : '';

            // If this is a retry (attempts > 0), reason is required
            if (attempts > 0 && !reason) {
                if (errorSpan) {
                    errorSpan.textContent = 'Reasoning is required for retry attempts.';
                    errorSpan.classList.add('show');
                }
                reasonTextarea.classList.add('required');
                reasonTextarea.focus();
                return;
            }

            // Save answer
            if (!classData.users[currentUsername]) {
                classData.users[currentUsername] = {
                    answers: {},
                    reasons: {},
                    timestamps: {},
                    attempts: {}
                };
            }

            classData.users[currentUsername].answers[questionId] = {
                value: value,
                timestamp: new Date().toISOString()
            };
            classData.users[currentUsername].reasons[questionId] = reason;
            classData.users[currentUsername].timestamps[questionId] = new Date().toISOString();
            classData.users[currentUsername].attempts[questionId] = attempts + 1;

            saveClassData();

            // Update UI
            const submitBtn = document.getElementById(`submit-${questionId}`);
            const qContainer = document.querySelector(`[data-question-id="${questionId}"]`);
            
            // Update button
            if (submitBtn) {
                if (!canRetry(questionId)) {
                    submitBtn.textContent = 'Max Attempts Reached';
                    submitBtn.disabled = true;
                } else {
                    submitBtn.textContent = 'Update Answer';
                }
            }

            // Show success message with correctness feedback
            if (successSpan) {
                const correctAnswer = getCorrectAnswer(questionId);
                let isCorrect = false;
                if (correctAnswer && value) {
                    isCorrect = (value.toString().toLowerCase().trim() === correctAnswer.toString().toLowerCase().trim());
                }

                if (isCorrect) {
                    successSpan.textContent = '✅ Correct answer submitted!';
                    successSpan.style.color = '#27ae60';
                } else {
                    successSpan.textContent = '📝 Answer submitted successfully!';
                    successSpan.style.color = '#3498db';
                }

                successSpan.classList.add('show');
                setTimeout(() => {
                    successSpan.classList.remove('show');
                }, 3000);
            }

            // Update header to show answered
            const header = qContainer.querySelector('.question-header');
            if (header && !header.querySelector('span[style*="color"]')) {
                header.innerHTML += '<span style="color: #a5d6a7;">✓ Answered</span>';
            }

            // Show/update dotplot immediately after submission (if it exists)
            const dotplotSection = document.getElementById(`dotplot-section-${questionId}`);

            // Ensure the section is visible (only if dotplot section exists)
            if (dotplotSection && !dotplotSection.classList.contains('show')) {
                dotplotSection.classList.add('show');
                dotplotSection.style.opacity = '0';
                setTimeout(() => {
                    dotplotSection.style.transition = 'opacity 0.3s ease';
                    dotplotSection.style.opacity = '1';
                }, 10);
            }

            // Always destroy existing chart to force complete refresh
            const chartId = `dotplot-${questionId}`;
            if (chartInstances[chartId]) {
                try {
                    chartInstances[chartId].destroy();
                } catch(e) {
                    console.log('Error destroying chart:', e);
                }
                delete chartInstances[chartId];
            }

            // Clear the canvas to ensure clean slate
            const canvas = document.getElementById(chartId);
            if (canvas) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }

            // Render the appropriate visualization with a small delay to ensure DOM is ready
            setTimeout(() => {
                if (questionType === 'multiple-choice') {
                    renderMCQDistribution(questionId);
                } else {
                    renderFRQResponses(questionId);
                }

                // Populate peer reasoning after chart rendering
                populatePeerResponses(questionId, questionType);
            }, 50);

            // Trigger answer key display logic
            const correctAnswer = getCorrectAnswer(questionId);
            console.log(`DEBUG: User answer: "${value}", Correct answer: "${correctAnswer}"`);

            let isCorrect = false;
            if (correctAnswer && value) {
                isCorrect = (value.toString().toLowerCase().trim() === correctAnswer.toString().toLowerCase().trim());
            }
            console.log(`DEBUG: Answer is ${isCorrect ? 'CORRECT' : 'INCORRECT'}`);

            const hasExplanation = (reason && reason.length > 0);
            console.log(`DEBUG: Has explanation: ${hasExplanation}`);

            displayAnswerKey(questionId, isCorrect, hasExplanation, attempts + 1);
        }

        // Show dotplot
        function showDotplot(questionId, questionType) {
    const dotplotSection = document.getElementById(`dotplot-section-${questionId}`);
    if (!dotplotSection) return;

    // Ensure the section has all required containers
    if (!document.getElementById(`dotplot-${questionId}`)) {
        dotplotSection.innerHTML = `
            <canvas id="dotplot-${questionId}" width="400" height="200"></canvas>
            <div id="consensus-${questionId}"></div>
            <div class="contributors-list" id="contributors-${questionId}"></div>
        `;
    }

    // Always destroy existing chart first to force refresh
    if (chartInstances[`dotplot-${questionId}`]) {
        chartInstances[`dotplot-${questionId}`].destroy();
        delete chartInstances[`dotplot-${questionId}`];
    }

    // Show the section with animation
    if (!dotplotSection.classList.contains('show')) {
        dotplotSection.classList.add('show');
        dotplotSection.style.opacity = '0';
        setTimeout(() => {
            dotplotSection.style.transition = 'opacity 0.3s ease';
            dotplotSection.style.opacity = '1';
        }, 10);
    }

    // Render with a small delay to ensure DOM is ready
    setTimeout(() => {
        if (questionType === 'multiple-choice') {
            renderMCQDistribution(questionId);
        } else {
            renderFRQResponses(questionId);
        }
    }, 50);
}

        // Render MCQ distribution
        function renderMCQDistribution(questionId) {
            const canvas = document.getElementById(`dotplot-${questionId}`);
            if (!canvas) return;

            // Fix canvas dimensions to prevent cropping
            const container = canvas.parentElement;
            container.style.height = '500px';  // Increased from 350px
            container.style.position = 'relative';
            container.style.overflow = 'visible';  // Changed from 'hidden' to 'visible'

            // Ensure the canvas itself has room
            canvas.style.height = '600px';  // Increased from 300px
            canvas.style.width = '100%';

            // Aggregate responses
            const choiceCounts = {};
            let totalCount = 0;
            const contributors = [];

            // Get the question to know all possible choices
            const question = currentQuestions.find(q => q.id === questionId);
            const allChoices = question?.choices || question?.attachments?.choices || [];

            // Initialize all choices with 0
            allChoices.forEach(choice => {
                choiceCounts[choice.key] = 0;
            });

            // Count actual responses
            for (let username in classData.users) {
                const userAnswer = classData.users[username].answers?.[questionId];
                if (userAnswer) {
                    const choice = userAnswer.value || userAnswer;
                    const reason = classData.users[username].reasons?.[questionId] || '';

                    choiceCounts[choice] = (choiceCounts[choice] || 0) + 1;
                    totalCount++;
                    contributors.push({
                        username: username,
                        choice: choice,
                        reason: reason
                    });
                }
            }

            // Create bar chart (like your example JSON)
            const ctx = canvas.getContext('2d');
            const choices = Object.keys(choiceCounts).sort();
            const counts = choices.map(c => choiceCounts[c] || 0);
            const relativeFrequencies = counts.map(c => totalCount > 0 ? c / totalCount : 0);

            // Destroy existing chart if any
            // Destroy existing chart if any
if (chartInstances[`dotplot-${questionId}`]) {
    chartInstances[`dotplot-${questionId}`].destroy();
    delete chartInstances[`dotplot-${questionId}`];  // Add just this line
}
            // Create bar chart with relative frequencies
            chartInstances[`dotplot-${questionId}`] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: choices,
                    datasets: [{
                        label: 'Relative Frequency',
                        data: relativeFrequencies,
                        backgroundColor: choices.map(c => {
                            // Highlight user's choice in different color
                            const userChoice = classData.users[currentUsername]?.answers?.[questionId];
                            const userChoiceValue = userChoice?.value || userChoice;
                            return c === userChoiceValue ? '#4CAF50' : '#36A2EB';
                        }),
                        borderColor: '#2196F3',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: {
                            bottom: 20
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 1,
                            ticks: {
                                stepSize: 0.1,
                                callback: function(value) {
                                    return (value * 100).toFixed(0) + '%';
                                }
                            },
                            title: {
                                display: true,
                                text: 'Relative Frequency'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Answer Choice'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const value = context.parsed.y;
                                    const percentage = (value * 100).toFixed(1);
                                    const count = counts[context.dataIndex];
                                    return `${percentage}% (${count} of ${totalCount} responses)`;
                                }
                            }
                        }
                    }
                }
            });

            // Add consensus coloring
            const maxFreq = Math.max(...relativeFrequencies);
            const consensusDiv = document.getElementById(`consensus-${questionId}`);
            if (maxFreq >= 0.7) {
                consensusDiv.style.backgroundColor = '#e8f5e9';
                consensusDiv.style.border = '2px solid #4CAF50';
            } else if (maxFreq >= 0.6) {
                consensusDiv.style.backgroundColor = '#fff3e0';
                consensusDiv.style.border = '2px solid #ff9800';
            } else {
                consensusDiv.style.backgroundColor = '#ffebee';
                consensusDiv.style.border = '2px solid #f44336';
            }

            // Show consensus message
            if (consensusDiv) {
                if (totalCount > 1) {
                    const modeIndex = relativeFrequencies.indexOf(maxFreq);
                    const mode = choices[modeIndex];
                    const percentage = (maxFreq * 100).toFixed(0);

                    // Check for consensus (70% or more agreement)
                    if (maxFreq >= 0.7) {
                        consensusDiv.innerHTML = `
                            <div class="consensus-msg consensus">
                                ✓ Consensus reached on choice ${mode} (${percentage}% agreement)
                            </div>
                        `;
                    } else {
                        consensusDiv.innerHTML = `
                            <div class="consensus-msg no-consensus">
                                No consensus yet - highest agreement: ${mode} at ${percentage}%
                            </div>
                        `;
                    }
                } else {
                    consensusDiv.innerHTML = `
                        <div class="consensus-msg no-consensus">
                            You're the first to answer! Import class data to see peer responses.
                        </div>
                    `;
                }
            }

            // Show contributors with their choices and reasons
            const contributorsDiv = document.getElementById(`contributors-${questionId}`);
            if (contributorsDiv && contributors.length > 0) {
                let html = '<h4 style="margin-top: 10px;">Individual Responses:</h4>';
                contributors.forEach(c => {
                    const isCurrentUser = c.username === currentUsername;
                    const badges = calculateBadges(c.username);
                    const badgeText = badges.length > 0 ? ` ${badges.join(' ')}` : '';

                    // CRITICAL: Always show the reason if it exists
                    html += `
                        <div class="contributor-item" style="${isCurrentUser ? 'background: #e3f2fd;' : ''}">
                            <span class="contributor-choice">${c.username}${badgeText} → Choice ${c.choice}</span>
                            ${c.reason ? `<div class="contributor-reason" style="margin-top: 5px; padding: 8px; background: #f9f9f9; border-left: 3px solid #2196F3; font-style: italic;">"${c.reason}"</div>` : '<div style="color: #999; font-style: italic; margin-top: 5px;">No explanation provided</div>'}
                        </div>
                    `;
                });
                contributorsDiv.innerHTML = html;
            }

            // ALSO populate the sidebar peer reasoning section
            populatePeerReasoning(questionId, contributors);
        }

        // Function to populate the sidebar peer reasoning section
        function populatePeerReasoning(questionId, contributors) {
            const peerReasoningContent = document.getElementById(`peer-reasoning-content-${questionId}`);
            const peerCount = document.getElementById(`peer-count-${questionId}`);

            if (!peerReasoningContent) return;

            // Update peer count
            if (peerCount) {
                const totalPeers = contributors.filter(c => c.username !== currentUsername).length;
                peerCount.textContent = `${totalPeers} peers`;
            }

            if (contributors.length === 0) {
                peerReasoningContent.innerHTML = '<div class="peer-hint">No peer responses available yet</div>';
                return;
            }

            // Filter out current user and sort by reasoning quality
            const peerResponses = contributors
                .filter(c => c.username !== currentUsername)
                .sort((a, b) => {
                    // Sort: those with reasons first, then alphabetically
                    if (a.reason && !b.reason) return -1;
                    if (!a.reason && b.reason) return 1;
                    return a.username.localeCompare(b.username);
                });

            if (peerResponses.length === 0) {
                peerReasoningContent.innerHTML = '<div class="peer-hint">You\'re the first to answer this question!</div>';
                return;
            }

            // Generate peer response cards
            let html = '';
            peerResponses.forEach(peer => {
                const badges = calculateBadges(peer.username);
                const badgeText = badges.length > 0 ? ` ${badges.join(' ')}` : '';
                const hasReason = peer.reason && peer.reason.trim().length > 0;

                // Determine if answer is correct (basic heuristic - could be enhanced)
                const isCorrect = badgeText.includes('🏆') || badgeText.includes('⭐');

                html += `
                    <div class="peer-response-card ${isCorrect ? 'correct' : 'incorrect'}">
                        <div class="peer-name">${peer.username}${badgeText}</div>
                        <div class="peer-answer"><strong>Answer:</strong> ${peer.choice || peer.response} ${isCorrect ? '✓' : ''}</div>
                        ${hasReason ?
                            `<div class="peer-reasoning-text">"${peer.reason}"</div>` :
                            '<div class="peer-reasoning-text" style="color: #999;">No explanation provided</div>'
                        }
                    </div>
                `;
            });

            peerReasoningContent.innerHTML = html;
        }

        // Render FRQ responses
        function renderFRQResponses(questionId) {
            const canvas = document.getElementById(`dotplot-${questionId}`);
            const consensusDiv = document.getElementById(`consensus-${questionId}`);
            const contributorsDiv = document.getElementById(`contributors-${questionId}`);
            
            if (canvas) canvas.style.display = 'none';
            
            const responses = [];
            for (let username in classData.users) {
                const userAnswer = classData.users[username].answers?.[questionId];
                if (userAnswer) {
                    const response = userAnswer.value || userAnswer;
                    const reason = classData.users[username].reasons?.[questionId] || '';
                    responses.push({
                        username: username,
                        response: response,
                        reason: reason
                    });
                }
            }
            
            if (consensusDiv) {
                if (responses.length > 1) {
                    consensusDiv.innerHTML = `
                        <div class="consensus-msg no-consensus">
                            ${responses.length} responses submitted. Review peer responses below.
                        </div>
                    `;
                } else {
                    consensusDiv.innerHTML = `
                        <div class="consensus-msg no-consensus">
                            Your response recorded. Import class data to see peer responses.
                        </div>
                    `;
                }
            }
            
            if (contributorsDiv) {
                let html = '<h4>Responses:</h4>';
                responses.forEach(r => {
                    const userVotes = classData.users[currentUsername]?.votes?.[questionId]?.[r.username] || {};
                    html += `
                        <div class="contributor-item">
                            <strong>${r.username}:</strong>
                            <div style="margin-top: 5px; padding: 10px; background: #f5f5f5; border-radius: 4px;">
                                ${r.response}
                            </div>
                            ${r.reason ? `<div class="contributor-reason">${r.reason}</div>` : ''}
                            <div style="margin-top: 10px;">
                                <button onclick="voteFRQ('${questionId}', '${r.username}', 'helpful')"
                                        class="vote-btn ${userVotes.type === 'helpful' ? 'active' : ''}">
                                    💡 Helpful (${getVoteCount(questionId, r.username, 'helpful')})
                                </button>
                                <button onclick="voteFRQ('${questionId}', '${r.username}', 'unclear')"
                                        class="vote-btn ${userVotes.type === 'unclear' ? 'active' : ''}">
                                    🤔 Unclear (${getVoteCount(questionId, r.username, 'unclear')})
                                </button>
                                <button onclick="voteFRQ('${questionId}', '${r.username}', 'contradicts')"
                                        class="vote-btn ${userVotes.type === 'contradicts' ? 'active' : ''}">
                                    ⚔️ Contradicts (${getVoteCount(questionId, r.username, 'contradicts')})
                                </button>
                            </div>
                        </div>
                    `;
                });
                contributorsDiv.innerHTML = html;
            }

            // ALSO populate the sidebar peer reasoning section for FRQ
            const frqContributors = responses.map(r => ({
                username: r.username,
                choice: 'FRQ Response',
                response: r.response,
                reason: r.reason
            }));
            populatePeerReasoning(questionId, frqContributors);
        }

        // Add explanation retroactively to enable retry
        window.addExplanationToRetry = function(questionId) {
            const reasonTextarea = document.getElementById(`reason-${questionId}`);
            const addExplanationBtn = document.getElementById(`add-explanation-${questionId}`);
            const submitBtn = document.getElementById(`submit-${questionId}`);
            const errorSpan = document.getElementById(`error-${questionId}`);
            const successSpan = document.getElementById(`success-${questionId}`);

            // Clear previous messages
            if (errorSpan) {
                errorSpan.textContent = '';
                errorSpan.classList.remove('show');
            }
            if (successSpan) {
                successSpan.textContent = '';
                successSpan.classList.remove('show');
            }

            // Check if explanation is provided
            const explanation = reasonTextarea ? reasonTextarea.value.trim() : '';
            if (!explanation) {
                if (errorSpan) {
                    errorSpan.textContent = 'Please provide an explanation first.';
                    errorSpan.classList.add('show');
                }
                // Focus on the textarea
                if (reasonTextarea) {
                    reasonTextarea.focus();
                    reasonTextarea.classList.add('required');
                }
                return;
            }

            // Save the explanation
            if (!classData.users[currentUsername]) {
                classData.users[currentUsername] = {
                    answers: {},
                    reasons: {},
                    timestamps: {},
                    attempts: {}
                };
            }

            classData.users[currentUsername].reasons[questionId] = explanation;
            saveClassData();

            // Update UI to enable retry
            if (addExplanationBtn) {
                addExplanationBtn.style.display = 'none';
            }

            if (submitBtn) {
                submitBtn.disabled = false;
                submitBtn.textContent = 'Update Answer';
            }

            // Re-enable form inputs for answer changes
            // Enable radio buttons for multiple choice
            const radioButtons = document.querySelectorAll(`input[name="choice-${questionId}"]`);
            radioButtons.forEach(radio => {
                radio.disabled = false;
            });

            // Enable FRQ textarea
            const frqTextarea = document.getElementById(`frq-${questionId}`);
            if (frqTextarea) {
                frqTextarea.disabled = false;
            }

            // Remove disabled styling from choice divs
            const choiceDivs = document.querySelectorAll(`[data-question-id="${questionId}"] .choice.disabled`);
            choiceDivs.forEach(choiceDiv => {
                choiceDiv.classList.remove('disabled');
            });

            // Show success message
            if (successSpan) {
                successSpan.textContent = 'Explanation added! You can now change your answer and retry.';
                successSpan.classList.add('show');
                setTimeout(() => {
                    successSpan.classList.remove('show');
                }, 4000);
            }

            // Remove required styling from textarea
            if (reasonTextarea) {
                reasonTextarea.classList.remove('required');
            }

            // Update placeholder text
            if (reasonTextarea) {
                reasonTextarea.placeholder = 'Explanation saved. You can now update your answer.';
            }
        }

        // Get correct answer from curriculum data
        function getCorrectAnswer(questionId) {
            // Find the question in the current questions array
            const question = currentQuestions.find(q => q.id === questionId);
            console.log(`DEBUG getCorrectAnswer: Question found:`, question);

            // Check for answerKey field (most common)
            if (question && question.answerKey) {
                console.log(`DEBUG getCorrectAnswer: Answer key found: "${question.answerKey}"`);
                return question.answerKey;
            }

            // Check for correct_answer field
            if (question && question.correct_answer) {
                console.log(`DEBUG getCorrectAnswer: Correct answer found: "${question.correct_answer}"`);
                return question.correct_answer;
            }

            // Check for answer field
            if (question && question.answer) {
                console.log(`DEBUG getCorrectAnswer: Answer field found: "${question.answer}"`);
                return question.answer;
            }

            console.log(`DEBUG getCorrectAnswer: No correct answer found for question ${questionId}`);
            return null;
        }

        // Get official explanation from curriculum data
        function getOfficialExplanation(questionId) {
            // Find the question in the current questions array
            const question = currentQuestions.find(q => q.id === questionId);
            console.log(`DEBUG getOfficialExplanation: Question found:`, question);

            // Check for various possible explanation field names
            if (question && question.explanation) {
                console.log(`DEBUG getOfficialExplanation: Explanation found: "${question.explanation}"`);
                return question.explanation;
            }

            if (question && question.rationale) {
                console.log(`DEBUG getOfficialExplanation: Rationale found: "${question.rationale}"`);
                return question.rationale;
            }

            if (question && question.solution) {
                console.log(`DEBUG getOfficialExplanation: Solution found: "${question.solution}"`);
                return question.solution;
            }

            if (question && question.reasoning) {
                console.log(`DEBUG getOfficialExplanation: Reasoning found: "${question.reasoning}"`);
                return question.reasoning;
            }

            // Check if attachments has explanation
            if (question && question.attachments && question.attachments.explanation) {
                console.log(`DEBUG getOfficialExplanation: Attachments explanation found: "${question.attachments.explanation}"`);
                return question.attachments.explanation;
            }

            console.log(`DEBUG getOfficialExplanation: No explanation found for question ${questionId}`);
            console.log(`DEBUG getOfficialExplanation: Available fields:`, Object.keys(question || {}));
            return null;
        }

        // Display College Board explanation below question (not in localStorage)
        function displayCollegeBoardExplanation(questionId) {
            console.log(`DEBUG: displayCollegeBoardExplanation called for ${questionId}`);

            const correctAnswer = getCorrectAnswer(questionId);
            const officialExplanation = getOfficialExplanation(questionId);

            console.log(`DEBUG: correctAnswer: ${correctAnswer}, officialExplanation: ${officialExplanation}`);

            if (correctAnswer) {
                // Find or create College Board explanation section
                let cbSection = document.getElementById(`college-board-explanation-${questionId}`);

                if (!cbSection) {
                    // Create the section below the answer key section
                    const answerKeySection = document.getElementById(`answer-key-${questionId}`);
                    if (answerKeySection) {
                        cbSection = document.createElement('div');
                        cbSection.id = `college-board-explanation-${questionId}`;
                        cbSection.className = 'college-board-explanation-section';
                        answerKeySection.parentNode.insertBefore(cbSection, answerKeySection.nextSibling);
                    }
                }

                if (cbSection) {
                    cbSection.style.display = 'block'; // Ensure it's visible for answer key detection
                    cbSection.innerHTML = `
                        <div class="college-board-content">
                            <h4>🏛️ College Board Official Explanation</h4>
                            <div class="cb-correct-answer">
                                <strong>Correct Answer:</strong> ${correctAnswer}
                            </div>
                            <div class="cb-official-explanation">
                                ${officialExplanation || 'Official explanation not available for this question. You got it right!'}
                            </div>
                        </div>
                    `;
                    cbSection.style.display = 'block';

                    // Change reasoning textarea border to gold
                    const reasonTextarea = document.getElementById(`reason-${questionId}`);
                    if (reasonTextarea) {
                        reasonTextarea.style.borderColor = '#f39c12';
                        reasonTextarea.style.boxShadow = '0 0 0 0.2rem rgba(243, 156, 18, 0.25)';
                    }

                    console.log(`DEBUG: College Board explanation displayed for ${questionId}`);

                    // Refresh peer responses to update correctness colors IMMEDIATELY
                    console.log(`DEBUG: About to refresh peer responses for color update`);
                    const question = currentQuestions.find(q => q.id === questionId);
                    if (question) {
                        // Add a small delay to ensure DOM is fully updated
                        setTimeout(() => {
                            populatePeerResponses(questionId, question.type);
                            console.log(`DEBUG: Peer responses refreshed for ${questionId} (after timeout)`);
                        }, 100);
                    } else {
                        console.log(`DEBUG: Question not found for refresh: ${questionId}`);
                    }
                }
            } else {
                console.log(`DEBUG: Missing data - correctAnswer: ${correctAnswer}, explanation: ${officialExplanation}`);
            }
        }

        // Display answer key with timer-based logic
        function displayAnswerKey(questionId, isCorrect, hasExplanation, attemptNumber) {
            const answerKeySection = document.getElementById(`answer-key-${questionId}`);
            const correctAnswerDiv = document.getElementById(`correct-answer-${questionId}`);
            const officialExplanationDiv = document.getElementById(`official-explanation-${questionId}`);

            if (!answerKeySection) return;

            // Clear any existing timers for this question
            if (window.answerKeyTimers && window.answerKeyTimers[questionId]) {
                clearTimeout(window.answerKeyTimers[questionId]);
                delete window.answerKeyTimers[questionId];
            }

            // Initialize timers object if needed
            if (!window.answerKeyTimers) {
                window.answerKeyTimers = {};
            }

            // Get correct answer and explanation
            const correctAnswer = getCorrectAnswer(questionId);
            const officialExplanation = getOfficialExplanation(questionId);

            // Populate answer key content (but we'll primarily show this in peer section now)
            if (correctAnswerDiv && correctAnswer) {
                correctAnswerDiv.innerHTML = `<strong>Correct Answer:</strong> ${correctAnswer}`;
            }

            if (officialExplanationDiv && officialExplanation) {
                officialExplanationDiv.innerHTML = `<strong>Official Explanation:</strong><br>${officialExplanation}`;
            }

            // Apply timer logic based on user's performance
            if (attemptNumber === 1) {
                // First attempt
                if (isCorrect && hasExplanation) {
                    // ✅ Correct + Explanation: Immediate answer key and College Board explanation
                    answerKeySection.style.display = 'block';
                    displayCollegeBoardExplanation(questionId);
                    console.log(`Answer key shown immediately: correct with explanation for ${questionId}`);
                } else if (isCorrect && !hasExplanation) {
                    // ⏰ Correct + No Explanation: 15-minute timer
                    console.log(`Starting 15-minute timer for ${questionId} (correct, no explanation)`);
                    window.answerKeyTimers[questionId] = setTimeout(() => {
                        answerKeySection.style.display = 'block';
                        displayCollegeBoardExplanation(questionId);
                        showMessage('Answer key revealed after 15 minutes (correct answer)', 'info');
                    }, 15 * 60 * 1000); // 15 minutes
                } else {
                    // ❌ Incorrect: No answer key until explanation provided or max attempts
                    console.log(`Answer key blocked for ${questionId} (incorrect answer)`);
                }
            } else if (attemptNumber === 2) {
                // Second attempt
                if (isCorrect && hasExplanation) {
                    // ✅ Correct on retry + Explanation: Immediate answer key and College Board explanation
                    answerKeySection.style.display = 'block';
                    displayCollegeBoardExplanation(questionId);
                    console.log(`Answer key shown immediately: correct on retry with explanation for ${questionId}`);
                } else if (isCorrect && !hasExplanation) {
                    // ⏰ Correct on retry + No Explanation: 15-minute timer
                    console.log(`Starting 15-minute timer for ${questionId} (correct on retry, no explanation)`);
                    window.answerKeyTimers[questionId] = setTimeout(() => {
                        answerKeySection.style.display = 'block';
                        displayCollegeBoardExplanation(questionId);
                        showMessage('Answer key revealed after 15 minutes (correct on retry)', 'info');
                    }, 15 * 60 * 1000); // 15 minutes
                }
            } else if (attemptNumber >= 3) {
                // Third attempt reached
                if (!isCorrect) {
                    // Still wrong after 3 attempts: 5-minute timer
                    console.log(`Starting 5-minute timer for ${questionId} (wrong after 3 attempts)`);
                    window.answerKeyTimers[questionId] = setTimeout(() => {
                        answerKeySection.style.display = 'block';
                        displayCollegeBoardExplanation(questionId);
                        showMessage('Answer key revealed after 5 minutes (3 incorrect attempts)', 'warning');
                    }, 5 * 60 * 1000); // 5 minutes
                } else if (hasExplanation) {
                    // ✅ Correct on retry + Explanation: Immediate answer key and College Board explanation
                    answerKeySection.style.display = 'block';
                    displayCollegeBoardExplanation(questionId);
                    console.log(`Answer key shown immediately: correct on retry with explanation for ${questionId}`);
                }
            }
        }

        // Function to show/hide answer key manually (for testing or override)
        function toggleAnswerKey(questionId, show = true) {
            const answerKeySection = document.getElementById(`answer-key-${questionId}`);
            if (answerKeySection) {
                answerKeySection.style.display = show ? 'block' : 'none';
            }
        }

        // Helper function to get vote count
        function getVoteCount(questionId, targetUser, voteType) {
            let count = 0;
            for (let username in classData.users) {
                const userVotes = classData.users[username].votes?.[questionId]?.[targetUser];
                if (userVotes?.type === voteType) {
                    count++;
                }
            }
            return count;
        }

        // Vote FRQ function
        window.voteFRQ = function(questionId, targetUser, voteType) {
            if (!classData.users[currentUsername].votes) {
                classData.users[currentUsername].votes = {};
            }
            if (!classData.users[currentUsername].votes[questionId]) {
                classData.users[currentUsername].votes[questionId] = {};
            }

            const existingVote = classData.users[currentUsername].votes[questionId][targetUser];
            if (existingVote?.type === voteType) {
                // Remove vote if clicking same button
                delete classData.users[currentUsername].votes[questionId][targetUser];
            } else {
                // Set new vote
                classData.users[currentUsername].votes[questionId][targetUser] = {
                    type: voteType,
                    timestamp: new Date().toISOString()
                };
            }

            saveClassData();
            renderFRQResponses(questionId);
        }

        // Load progress
        function loadProgress() {
            if (!currentUsername || !classData) return;

            // Add a counter for staggered rendering
            let renderDelay = 0;

            currentQuestions.forEach((question, index) => {
                const qId = question.id;
                const qContainer = document.querySelector(`[data-question-id="${qId}"]`);
                if (!qContainer) return;

                const isAnswered = isQuestionAnswered(qId);
                if (isAnswered) {
                    // Show dotplot with staggered delay to ensure proper rendering
                    const questionType = question.type;

                    // Use setTimeout with increasing delay for each question
                    setTimeout(() => {
                        // First ensure the dotplot section is visible
                        const dotplotSection = document.getElementById(`dotplot-section-${qId}`);
                        if (dotplotSection) {
                            dotplotSection.innerHTML = `
                                <canvas id="dotplot-${qId}" width="400" height="200"></canvas>
                                <div id="consensus-${qId}"></div>
                                <div class="contributors-list" id="contributors-${qId}"></div>
                            `;
                            dotplotSection.classList.add('show');
                            dotplotSection.style.opacity = '1';
                        }

                        // Now render the visualization
                        if (questionType === 'multiple-choice') {
                            renderMCQDistribution(qId);
                        } else {
                            renderFRQResponses(qId);
                        }
                    }, renderDelay);

                    // Increase delay for next question (100ms between each)
                    renderDelay += 100;

                    // Update button state
                    const submitBtn = document.getElementById(`submit-${qId}`);
                    if (submitBtn) {
                        if (!canRetry(qId)) {
                            submitBtn.textContent = 'Max Attempts Reached';
                            submitBtn.disabled = true;
                        } else {
                            submitBtn.textContent = 'Update Answer';
                        }
                    }
                }
            });
        }

        // ALTERNATE SOLUTION: If the above doesn't work, add this function to force refresh all visualizations:
        function refreshAllVisualizations() {
            // Call this after data import or when viewing past quizzes
            setTimeout(() => {
                currentQuestions.forEach((question, index) => {
                    const qId = question.id;
                    const isAnswered = isQuestionAnswered(qId);

                    if (isAnswered) {
                        setTimeout(() => {
                            const questionType = question.type;
                            if (questionType === 'multiple-choice') {
                                renderMCQDistribution(qId);
                            } else {
                                renderFRQResponses(qId);
                            }
                        }, index * 100); // Stagger by 100ms per question
                    }
                });
            }, 500); // Initial delay to ensure DOM is ready
        }

        // Export personal data
        window.exportPersonal = function() {
            const personalData = {
                exportTime: new Date().toISOString(),
                username: currentUsername,
                users: {
                    [currentUsername]: classData.users[currentUsername]
                }
            };
            
            const blob = new Blob([JSON.stringify(personalData, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${currentUsername}_data.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showMessage('Personal data exported successfully!', 'success');
        }

        // Export master database with all data
        window.exportMasterData = function() {
            // Get ALL data from localStorage, not filtered by user
            const masterData = {
                timestamp: new Date().toISOString(),
                exportType: 'master_database',
                allUsers: Object.keys(localStorage)
                    .filter(key => key.includes('_username') || key.includes('answers_'))
                    .map(key => key.split('_')[1])
                    .filter((v, i, a) => a.indexOf(v) === i), // unique usernames

                // Get all class data without filtering
                classData: JSON.parse(localStorage.getItem('classData') || '{}'),

                // Get all answers from all users
                allAnswers: {},

                // Get all progress from all users
                allProgress: {},

                // Get any other data structures you have
                consensusData: JSON.parse(localStorage.getItem('consensusResponses') || '{}'),

                // Include raw localStorage for complete backup
                rawLocalStorage: {}
            };

            // Collect all answers for all users
            Object.keys(localStorage).forEach(key => {
                if (key.startsWith('answers_')) {
                    const username = key.replace('answers_', '');
                    masterData.allAnswers[username] = JSON.parse(localStorage.getItem(key) || '{}');
                }
                if (key.startsWith('progress_')) {
                    const username = key.replace('progress_', '');
                    masterData.allProgress[username] = JSON.parse(localStorage.getItem(key) || '{}');
                }

                // Store everything in raw format too
                masterData.rawLocalStorage[key] = localStorage.getItem(key);
            });

            // Create and download the file
            const blob = new Blob([JSON.stringify(masterData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `master_database_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showMessage('Master database exported successfully!', 'success');
        }


        // Import class data
        window.importClassData = function(event) {
            console.log('=== importClassData called (sync modal) ===');
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    console.log('Sync modal - imported data:', importedData);
                    console.log('Sync modal - data keys:', Object.keys(importedData));

                    // Use the same detection logic as the main import
                    if (isMasterDataFile(importedData)) {
                        console.log('Sync modal - detected master database file');
                        importMasterData(importedData);
                        showMessage('✅ Master database imported successfully!', 'success');
                    } else if (importedData.exportType === 'master_database') {
                        console.log('Sync modal - legacy master database format');
                        mergeMasterData(importedData);
                    } else {
                        console.log('Sync modal - regular class data');
                        // Handle regular class data import (existing behavior)
                        mergeRegularClassData(importedData);
                    }

                } catch (error) {
                    console.error('Sync modal import error:', error);
                    showMessage('Error importing data: ' + error.message, 'error');
                }
            };
            reader.readAsText(file);
        }

        function mergeMasterData(masterData) {
            let updatedCount = 0;
            let preservedCount = 0;

            // Get current user's existing data
            let currentUserAnswers = JSON.parse(localStorage.getItem(`answers_${currentUsername}`) || '{}');
            // STANDARDIZATION FIX: Ensure existing data is also in standardized format
            currentUserAnswers = migrateAnswersToStandardFormat(currentUserAnswers);
            const currentUserProgress = JSON.parse(localStorage.getItem(`progress_${currentUsername}`) || '{}');

            // Merge class-wide data (consensus, etc.) - always take the master version for these
            if (masterData.classData) {
                localStorage.setItem('classData', JSON.stringify(masterData.classData));
            }
            if (masterData.consensusData) {
                localStorage.setItem('consensusResponses', JSON.stringify(masterData.consensusData));
            }

            // Import OTHER users' data completely (not the current user)
            if (masterData.allAnswers) {
                Object.keys(masterData.allAnswers).forEach(username => {
                    if (username !== currentUsername) {
                        // STANDARDIZATION FIX: Use migration function for other users' data
                        const standardizedAnswers = migrateAnswersToStandardFormat(masterData.allAnswers[username]);
                        localStorage.setItem(`answers_${username}`, JSON.stringify(standardizedAnswers));
                        updatedCount++;
                    }
                });
            }

            if (masterData.allProgress) {
                Object.keys(masterData.allProgress).forEach(username => {
                    if (username !== currentUsername) {
                        localStorage.setItem(`progress_${username}`, JSON.stringify(masterData.allProgress[username]));
                    }
                });
            }

            // For the CURRENT user, merge intelligently
            if (masterData.allAnswers && masterData.allAnswers[currentUsername]) {
                // STANDARDIZATION FIX: Standardize imported data first
                const standardizedImportedAnswers = migrateAnswersToStandardFormat(masterData.allAnswers[currentUsername]);
                const importedUserAnswers = standardizedImportedAnswers;

                // Merge answers - keep newer ones based on timestamp or attempt count
                Object.keys(importedUserAnswers).forEach(questionId => {
                    const importedAnswer = importedUserAnswers[questionId];
                    const currentAnswer = currentUserAnswers[questionId];

                    if (!currentAnswer) {
                        // No existing answer, take the imported one
                        currentUserAnswers[questionId] = importedAnswer;
                        updatedCount++;
                    } else {
                        // Compare and keep the better/newer one
                        // Option 1: Keep the one with more attempts (more work done)
                        if (importedAnswer.attempts && currentAnswer.attempts) {
                            if (importedAnswer.attempts > currentAnswer.attempts) {
                                currentUserAnswers[questionId] = importedAnswer;
                                updatedCount++;
                            } else {
                                preservedCount++;
                            }
                        }
                        // Option 2: Keep the one with a timestamp (if you have timestamps)
                        else if (importedAnswer.timestamp && currentAnswer.timestamp) {
                            if (new Date(importedAnswer.timestamp) > new Date(currentAnswer.timestamp)) {
                                currentUserAnswers[questionId] = importedAnswer;
                                updatedCount++;
                            } else {
                                preservedCount++;
                            }
                        }
                        // Option 3: Keep the one that's correct (if applicable)
                        else if (currentAnswer.correct) {
                            preservedCount++;
                        } else if (importedAnswer.correct) {
                            currentUserAnswers[questionId] = importedAnswer;
                            updatedCount++;
                        } else {
                            // Default: preserve current
                            preservedCount++;
                        }
                    }
                });

                // Save the merged answers
                localStorage.setItem(`answers_${currentUsername}`, JSON.stringify(currentUserAnswers));
            }

            // Merge progress similarly
            if (masterData.allProgress && masterData.allProgress[currentUsername]) {
                const importedProgress = masterData.allProgress[currentUsername];

                Object.keys(importedProgress).forEach(lessonId => {
                    if (!currentUserProgress[lessonId] ||
                        importedProgress[lessonId] > currentUserProgress[lessonId]) {
                        currentUserProgress[lessonId] = importedProgress[lessonId];
                    }
                });

                localStorage.setItem(`progress_${currentUsername}`, JSON.stringify(currentUserProgress));
            }

            // Import any other non-user-specific data from rawLocalStorage
            if (masterData.rawLocalStorage) {
                Object.keys(masterData.rawLocalStorage).forEach(key => {
                    // Skip user-specific data for current user
                    if (!key.includes(`_${currentUsername}`) &&
                        !key.startsWith('answers_') &&
                        !key.startsWith('progress_')) {

                        // Only import if it doesn't exist or is older
                        const existingData = localStorage.getItem(key);
                        if (!existingData) {
                            localStorage.setItem(key, masterData.rawLocalStorage[key]);
                        }
                    }
                });
            }

            showMessage(`Master data merged! Updated: ${updatedCount} items, Preserved your work: ${preservedCount} items`, 'success');

            // Reload to show the updated data
            setTimeout(() => location.reload(), 2000);
        }

        function mergeRegularClassData(importedData) {
            // Your existing import logic for regular class data
            // This handles non-master imports as before
            const classData = JSON.parse(localStorage.getItem('classData') || '{}');

            // Merge the imported data with existing...
            // [Your existing merge logic here]

            localStorage.setItem('classData', JSON.stringify(classData));
            showMessage('Class data imported successfully!', 'success');
            location.reload();
        }

        // Show message
        function showMessage(text, type) {
            const messageArea = document.getElementById('messageArea');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            messageDiv.textContent = text;
            
            messageArea.innerHTML = '';
            messageArea.appendChild(messageDiv);
            
            setTimeout(() => {
                messageDiv.style.opacity = '0';
                setTimeout(() => messageArea.innerHTML = '', 300);
            }, 5000);
        }

        // Theme management
        function initTheme() {
            const savedTheme = localStorage.getItem('quizTheme') || 'light';
            currentTheme = savedTheme;
            applyTheme(savedTheme);
        }

        function applyTheme(theme) {
            const body = document.body;
            const themeButton = document.querySelector('.theme-toggle');
            
            if (theme === 'dark') {
                body.classList.add('dark-theme');
                if (themeButton) themeButton.textContent = '☀️';
            } else {
                body.classList.remove('dark-theme');
                if (themeButton) themeButton.textContent = '🌙';
            }
            
            currentTheme = theme;
            localStorage.setItem('quizTheme', theme);
        }

        window.toggleTheme = function() {
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            applyTheme(newTheme);
        }

        // Initialize on load
        window.onload = function() {
            initTheme();
            
            // Check localStorage support
            if (!window.localStorage) {
                showMessage('Warning: LocalStorage is not available. Data will not be saved.', 'error');
            }
            
            promptUsername();
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Ctrl+S to export data
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                if (currentUsername) {
                    exportPersonal();
                }
            }
        });

        // Intersection Observer for lazy loading charts (optional enhancement)
        if ('IntersectionObserver' in window) {
            const chartObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const container = entry.target;
                        const chartId = container.dataset.chartId;
                        if (chartId && window.pendingCharts && window.pendingCharts[chartId]) {
                            renderChartNow(chartId);
                            delete window.pendingCharts[chartId];
                            chartObserver.unobserve(container);
                        }
                    }
                });
            }, {
                rootMargin: '100px'
            });
            
            // Observe chart containers when they're created
            window.observeChartContainers = function() {
                document.querySelectorAll('[data-chart-id]').forEach(container => {
                    chartObserver.observe(container);
                });
            }
        }

        // Pig Sprite Controller
        class PigSprite {
            constructor(color = 'pink') {
                this.x = window.innerWidth / 2;
                this.y = 100;
                this.frame = 0;
                this.animationRow = 0; // 0 for top row, 1 for bottom row
                this.facingRight = true;
                this.isJumping = false;
                this.velocity = { x: 0, y: 0 };
                this.color = color;

                // Collision detection properties
                this.headerCollisions = 0;
                this.bounceThreshold = 3; // Number of bounces before triggering action

                // Button physics properties
                this.buttons = []; // Registry of button elements for collision
                this.onPlatform = false; // Whether sprite is standing on a button
                this.platformElement = null; // Current platform button

                this.createElement();
                this.updateButtonRegistry(); // Initialize button detection
                this.bindControls();
                this.startAnimation();
            }

            createElement() {
                this.element = document.createElement('div');
                this.element.className = 'pig-sprite';
                this.element.style.left = this.x + 'px';
                this.element.style.bottom = this.y + 'px';

                // Apply color filter if needed
                if (this.color !== 'pink') {
                    this.element.style.filter = this.getColorFilter(this.color);
                }

                document.body.appendChild(this.element);
            }

            getColorFilter(color) {
                // CSS filters to change pig color
                const filters = {
                    'blue': 'hue-rotate(200deg)',
                    'green': 'hue-rotate(90deg)',
                    'purple': 'hue-rotate(270deg)',
                    'yellow': 'hue-rotate(45deg) saturate(1.5)',
                    'red': 'hue-rotate(-10deg) saturate(1.5)',
                    'gray': 'grayscale(100%)'
                };
                return filters[color] || '';
            }

            bindControls() {
                document.addEventListener('keydown', (e) => {
                    // Add this check before the switch statement
                    const activeElement = document.activeElement;
                    const isTyping = activeElement && (
                        activeElement.tagName === 'TEXTAREA' ||
                        activeElement.tagName === 'INPUT' ||
                        activeElement.contentEditable === 'true' ||
                        activeElement.classList.contains('frq-textarea') ||
                        activeElement.classList.contains('reason-textarea')
                    );

                    // Don't capture keys if user is typing
                    if (isTyping) {
                        return;
                    }

                    switch(e.key) {
                        case 'ArrowLeft':
                            this.moveLeft();
                            e.preventDefault();
                            break;
                        case 'ArrowRight':
                            this.moveRight();
                            e.preventDefault();
                            break;
                        case 'ArrowUp':
                        case ' ':
                            this.jump();
                            e.preventDefault();
                            break;
                        case 'ArrowDown':
                            this.animationRow = this.animationRow === 0 ? 1 : 0;
                            e.preventDefault();
                            break;
                    }
                });

                document.addEventListener('keyup', (e) => {
                    // Add the same check here too
                    const activeElement = document.activeElement;
                    const isTyping = activeElement && (
                        activeElement.tagName === 'TEXTAREA' ||
                        activeElement.tagName === 'INPUT' ||
                        activeElement.contentEditable === 'true' ||
                        activeElement.classList.contains('frq-textarea') ||
                        activeElement.classList.contains('reason-textarea')
                    );

                    if (isTyping) {
                        return;
                    }

                    if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                        this.velocity.x = 0;
                    }
                });
            }

            moveLeft() {
                this.velocity.x = -5;
                this.facingRight = false;
                this.element.classList.add('facing-left');
            }

            moveRight() {
                this.velocity.x = 5;
                this.facingRight = true;
                this.element.classList.remove('facing-left');
            }

            jump() {
                if (!this.isJumping) {
                    this.isJumping = true;
                    this.velocity.y = 15;

                    setTimeout(() => {
                        this.isJumping = false;
                    }, 500);
                }
            }

            updatePosition() {
                // Update horizontal position
                if (this.velocity.x !== 0) {
                    this.x += this.velocity.x;
                    this.x = Math.max(0, Math.min(window.innerWidth - 32, this.x));
                    this.element.style.left = this.x + 'px';
                }

                // Update vertical position (gravity simulation)
                if (this.velocity.y > 0 || this.y > 100) {
                    this.y += this.velocity.y;
                    this.velocity.y -= 0.8; // gravity

                    // Check for welcome element collision
                    const welcomeElement = document.querySelector('.username-welcome');
                    if (welcomeElement && this.velocity.y > 0) {
                        const welcomeRect = welcomeElement.getBoundingClientRect();
                        const spriteRect = this.element.getBoundingClientRect();

                        // Check if sprite intersects with welcome element
                        if (this.checkCollision(spriteRect, welcomeRect)) {
                            // Collision with welcome element
                            this.headerCollisions++;
                            this.velocity.y = -Math.abs(this.velocity.y); // Bounce down

                            // Visual feedback for collision
                            this.element.style.filter = 'brightness(150%) ' + this.getColorFilter(this.color);
                            setTimeout(() => {
                                this.element.style.filter = this.getColorFilter(this.color);
                            }, 200);

                            // Check if we've reached the bounce threshold
                            if (this.headerCollisions >= this.bounceThreshold) {
                                this.triggerUsernameManagement();
                                this.headerCollisions = 0; // Reset counter
                            }

                            console.log(`Welcome element collision #${this.headerCollisions}`);
                        }
                    }

                    // Check button collisions
                    // Update button registry periodically for dynamic content
                    if (Math.random() < 0.1) { // 10% chance each frame
                        this.updateButtonRegistry();
                    }

                    if (this.onPlatform) {
                        // When on platform, maintain position and check for edge fall
                        if (this.platformElement) {
                            const platformRect = this.platformElement.element.getBoundingClientRect();
                            const spriteRect = this.element.getBoundingClientRect();

                            // Check if walked off edge
                            if (spriteRect.right < platformRect.left || spriteRect.left > platformRect.right) {
                                this.fallOffPlatform();
                            } else {
                                // Stay on platform - maintain y position ONLY if not jumping
                                if (this.velocity.y > 0) {
                                    // Jumping off platform - leave platform state
                                    this.onPlatform = false;
                                    this.platformElement = null;
                                } else {
                                    // Not jumping - maintain platform position
                                    this.y = window.innerHeight - platformRect.top;
                                    this.velocity.y = 0;
                                }
                            }
                        }
                    }

                    // Always check for button collisions (whether on platform or not)
                    if (this.checkButtonCollisions()) {
                        // Button collision handled, don't check ground
                        this.element.style.bottom = this.y + 'px';
                        return;
                    }

                    // Ground collision (only if not on platform)
                    if (!this.onPlatform && this.y <= 100) {
                        this.y = 100;
                        this.velocity.y = 0;
                    }

                    this.element.style.bottom = this.y + 'px';
                }
            }

            animate() {
                // Cycle through frames when moving
                if (this.velocity.x !== 0 || this.isJumping) {
                    this.frame = (this.frame + 1) % 11;
                } else {
                    this.frame = 0; // idle frame
                }

                // Update sprite background position
                const xOffset = -this.frame * 32;
                const yOffset = -this.animationRow * 32;
                this.element.style.backgroundPosition = `${xOffset}px ${yOffset}px`;
            }

            startAnimation() {
                setInterval(() => {
                    this.updatePosition();
                    this.animate();
                }, 50);
            }

            setColor(newColor) {
                this.color = newColor;
                this.element.style.filter = this.getColorFilter(newColor);

                // Save to localStorage with username
                if (currentUsername) {
                    localStorage.setItem(`pigColor_${currentUsername}`, newColor);
                }
            }

            checkCollision(spriteRect, welcomeRect) {
                // Check if two rectangles overlap
                return !(spriteRect.right < welcomeRect.left ||
                        spriteRect.left > welcomeRect.right ||
                        spriteRect.bottom < welcomeRect.top ||
                        spriteRect.top > welcomeRect.bottom);
            }

            updateButtonRegistry() {
                // Find all visible button elements
                this.buttons = [];
                const allButtons = document.querySelectorAll('button');

                allButtons.forEach(button => {
                    const rect = button.getBoundingClientRect();
                    // Only include visible buttons with reasonable size
                    if (rect.width > 20 && rect.height > 20 &&
                        rect.top < window.innerHeight && rect.bottom > 0) {
                        this.buttons.push({
                            element: button,
                            rect: rect
                        });
                    }
                });
            }

            checkButtonCollisions() {
                const spriteRect = this.element.getBoundingClientRect();

                for (const buttonData of this.buttons) {
                    const buttonRect = buttonData.rect;

                    // Create expanded collision area above button for easier landing
                    const expandedRect = {
                        left: buttonRect.left,
                        right: buttonRect.right,
                        top: buttonRect.top - 25, // Expand 25px above button
                        bottom: buttonRect.bottom,
                        width: buttonRect.width,
                        height: buttonRect.height + 25
                    };

                    // Check for collision with expanded area
                    if (this.checkCollision(spriteRect, expandedRect)) {
                        const spriteCenterX = spriteRect.left + spriteRect.width / 2;
                        const spriteCenterY = spriteRect.top + spriteRect.height / 2;
                        const buttonCenterY = buttonRect.top + buttonRect.height / 2;

                        // Platform collision (sprite falling onto or near button top)
                        if (this.velocity.y >= 0) {
                            // Skip if already on this exact platform to prevent spam
                            if (this.onPlatform && this.platformElement === buttonData) {
                                continue;
                            }

                            // Calculate overlap percentage for horizontal overlap
                            const overlapLeft = Math.max(spriteRect.left, buttonRect.left);
                            const overlapRight = Math.min(spriteRect.right, buttonRect.right);
                            const overlapWidth = Math.max(0, overlapRight - overlapLeft);
                            const spriteWidth = spriteRect.width;
                            const overlapPercentage = (overlapWidth / spriteWidth) * 100;

                            // Check if pig is above or near button top and has sufficient overlap
                            if (spriteRect.bottom >= buttonRect.top - 5 &&
                                spriteRect.bottom <= buttonRect.top + 30 &&
                                overlapPercentage >= 50) {
                                this.landOnPlatform(buttonData, buttonRect);
                                return true;
                            }
                        }

                        // Bottom collision (sprite hitting button from below)
                        if (this.velocity.y < 0 && spriteCenterY > buttonCenterY) {
                            this.bounceOffBottom(buttonRect);
                            return true;
                        }
                    }
                }

                // Check if sprite has walked off platform edge
                if (this.onPlatform && this.platformElement) {
                    // Get current platform position (not cached)
                    const platformRect = this.platformElement.element.getBoundingClientRect();
                    if (spriteRect.right < platformRect.left || spriteRect.left > platformRect.right) {
                        this.fallOffPlatform();
                    }
                }

                return false;
            }

            landOnPlatform(buttonData, buttonRect) {
                // Stop falling and land on button
                // Calculate correct y position: pig bottom should touch button top
                this.y = window.innerHeight - buttonRect.top;
                this.velocity.y = 0;
                this.onPlatform = true;
                this.platformElement = buttonData;

                console.log(`Pig landed on button platform at y=${this.y}, button top=${buttonRect.top}, screen height=${window.innerHeight}`);
            }

            bounceOffBottom(buttonRect) {
                // Bounce off button bottom (like welcome element)
                this.velocity.y = -Math.abs(this.velocity.y);

                // Visual feedback
                this.element.style.filter = 'brightness(120%) ' + this.getColorFilter(this.color);
                setTimeout(() => {
                    this.element.style.filter = this.getColorFilter(this.color);
                }, 200);

                console.log('Pig bounced off button bottom');
            }

            fallOffPlatform() {
                // Fall off platform edge
                this.onPlatform = false;
                this.platformElement = null;
                console.log('Pig fell off platform edge');
            }

            triggerUsernameManagement() {
                // Add fun visual effect when triggering
                this.element.style.transform = 'scale(1.5) rotate(360deg)';
                this.element.style.transition = 'transform 0.5s ease';

                setTimeout(() => {
                    this.element.style.transform = '';
                    this.element.style.transition = '';
                }, 500);

                // Show message and trigger username prompt
                showMessage('🐷 Oink! Three bounces - returning to username screen!', 'info');

                setTimeout(() => {
                    this.showUsernameScreenWithWarning();
                }, 600);
            }

            showUsernameScreenWithWarning() {
                // Check if there's unsaved progress
                const hasUnsavedProgress = this.checkForUnsavedProgress();

                if (hasUnsavedProgress) {
                    const shouldContinue = confirm(
                        'Warning: You have unsaved progress that will be lost if you return to the username screen.\n\n' +
                        'Do you want to continue? (Your current progress will be lost)'
                    );

                    if (!shouldContinue) {
                        showMessage('Returning to current session - progress preserved!', 'success');
                        return;
                    }
                }

                // Clear current user and show username prompt
                localStorage.removeItem('consensusUsername');

                // Show username prompt
                if (typeof showUsernamePrompt === 'function') {
                    showUsernamePrompt();
                } else {
                    // Fallback to reload page
                    location.reload();
                }
            }

            checkForUnsavedProgress() {
                if (!currentUsername) return false;

                try {
                    // Check for any temporary progress markers
                    const tempProgress = localStorage.getItem(`tempProgress_${currentUsername}`);
                    if (tempProgress) return true;

                    // Check if user has answered any questions in current session that aren't saved
                    const sessionStart = localStorage.getItem(`sessionStart_${currentUsername}`);
                    if (!sessionStart) return false;

                    const sessionStartTime = new Date(sessionStart);
                    const userAnswers = JSON.parse(localStorage.getItem(`answers_${currentUsername}`) || '{}');

                    // Check if any answers were modified since session start
                    for (const [questionId, answerData] of Object.entries(userAnswers)) {
                        if (answerData.timestamp && new Date(answerData.timestamp) > sessionStartTime) {
                            // Mark unsaved progress if recent activity found
                            localStorage.setItem(`tempProgress_${currentUsername}`, 'true');
                            return true;
                        }
                    }

                    return false;
                } catch (error) {
                    console.error('Error checking unsaved progress:', error);
                    return false;
                }
            }
        }

        // Progress Tracking System
        function initializeProgressTracking() {
            if (!currentUsername) return;

            // Set session start time
            const now = new Date().toISOString();
            localStorage.setItem(`sessionStart_${currentUsername}`, now);

            // Clear any previous temporary progress markers
            localStorage.removeItem(`tempProgress_${currentUsername}`);

            console.log(`Progress tracking initialized for ${currentUsername} at ${now}`);

            // Check for import debug info from before page refresh
            const importDebug = localStorage.getItem('import_debug');
            if (importDebug) {
                const debugInfo = JSON.parse(importDebug);
                console.log('=== IMPORT DEBUG INFO (from before refresh) ===');
                console.log('Data keys:', debugInfo.dataKeys);
                console.log('Is personal file:', debugInfo.isPersonal);
                console.log('Is master file:', debugInfo.isMaster);
                console.log('Import timestamp:', debugInfo.timestamp);
                console.log('=== END IMPORT DEBUG ===');

                // Clear the debug info
                localStorage.removeItem('import_debug');
            }

            // Check for pending imports from before page refresh
            const pendingMaster = localStorage.getItem('pending_master_import');
            const pendingPersonal = localStorage.getItem('pending_personal_import');

            if (pendingMaster) {
                console.log('Processing pending master import...');
                try {
                    const data = JSON.parse(pendingMaster);
                    importMasterData(data);
                    console.log('✅ Master import completed after refresh');
                } catch (error) {
                    console.error('Error processing pending master import:', error);
                }
                localStorage.removeItem('pending_master_import');
            }

            if (pendingPersonal) {
                console.log('Processing pending personal import...');
                try {
                    const data = JSON.parse(pendingPersonal);
                    importPersonalData(data);
                    console.log('✅ Personal import completed after refresh');
                } catch (error) {
                    console.error('Error processing pending personal import:', error);
                }
                localStorage.removeItem('pending_personal_import');
            }
        }

        function markProgressAsUnsaved() {
            if (!currentUsername) return;
            localStorage.setItem(`tempProgress_${currentUsername}`, 'true');
            console.log(`Marked progress as unsaved for ${currentUsername}`);
        }

        function markProgressAsSaved() {
            if (!currentUsername) return;
            localStorage.removeItem(`tempProgress_${currentUsername}`);
            console.log(`Marked progress as saved for ${currentUsername}`);
        }

        function getProgressStatus() {
            if (!currentUsername) return { hasUnsavedProgress: false, sessionDuration: 0 };

            const sessionStart = localStorage.getItem(`sessionStart_${currentUsername}`);
            const tempProgress = localStorage.getItem(`tempProgress_${currentUsername}`);

            const sessionDuration = sessionStart ?
                (new Date() - new Date(sessionStart)) / 1000 / 60 : 0; // minutes

            return {
                hasUnsavedProgress: !!tempProgress,
                sessionDuration: sessionDuration,
                sessionStart: sessionStart
            };
        }

        // Enhanced answer saving that tracks progress
        function saveAnswerWithTracking(questionId, answer, options = {}) {
            if (!currentUsername) return;

            // Mark progress as unsaved when user makes changes
            markProgressAsUnsaved();

            // Call existing save answer function
            if (typeof saveAnswer === 'function') {
                saveAnswer(questionId, answer, options);
            }

            // Auto-save progress periodically
            clearTimeout(window.autoSaveTimeout);
            window.autoSaveTimeout = setTimeout(() => {
                markProgressAsSaved();
                console.log('Auto-saved progress');
            }, 30000); // 30 seconds delay
        }

        // Initialize the sprite when the page loads
        window.addEventListener('load', () => {
            // Initialize sprite immediately
            initializePigSprite();
        });

        // Function to initialize pig sprite based on current user
        function initializePigSprite() {
            // Remove existing sprite if present
            if (window.pigSprite && window.pigSprite.element) {
                window.pigSprite.element.remove();
            }

            // Load saved color for current user, or use default
            const savedColor = currentUsername ?
                localStorage.getItem(`pigColor_${currentUsername}`) || 'pink' :
                'pink';

            window.pigSprite = new PigSprite(savedColor);
        }

        // Add color picker to the UI
        function addColorPicker() {
            const colorPicker = document.createElement('div');
            colorPicker.innerHTML = `
                <div style="position: fixed; bottom: 20px; left: 20px; background: white; padding: 10px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.2); z-index: 1000;">
                    <label>Pig Color: </label>
                    <select id="pigColorSelect" onchange="if(window.pigSprite) window.pigSprite.setColor(this.value)">
                        <option value="pink">Pink</option>
                        <option value="blue">Blue</option>
                        <option value="green">Green</option>
                        <option value="purple">Purple</option>
                        <option value="yellow">Yellow</option>
                        <option value="red">Red</option>
                        <option value="gray">Gray</option>
                    </select>
                </div>
            `;
            document.body.appendChild(colorPicker);
        }

        // Add this to your window.onload
        window.addEventListener('load', () => {
            addColorPicker();
        });

    </script>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <script>
        // New function to render unit selection menu
        function renderUnitMenu() {
            const questionsContainer = document.getElementById('questionsContainer');

            // Sort units numerically
            const sortedUnits = Object.keys(allCurriculumData).sort((a, b) => parseInt(a) - parseInt(b));

            console.log('Rendering units:', sortedUnits); // Debug log

            let unitsHtml = '';
            sortedUnits.forEach(unitNum => {
                const unitData = allCurriculumData[unitNum];
                const unitName = unitStructure[unitNum]?.name || `Unit ${unitNum}`;
                const lessonCount = unitData.unitInfo.lessonNumbers.length;
                const questionCount = unitData.questions.length;

                console.log(`Unit ${unitNum}: ${questionCount} questions, ${lessonCount} lessons`); // Debug log

                // Calculate completion percentage for this unit
                let completedQuestions = 0;
                unitData.questions.forEach(q => {
                    if (isQuestionAnswered(q.id)) completedQuestions++;
                });
                const completionPercent = questionCount > 0 ? Math.round((completedQuestions / questionCount) * 100) : 0;

                unitsHtml += `
                    <div class="unit-card" onclick="selectUnit(${unitNum})">
                        <div class="unit-header">
                            <h3>Unit ${unitNum}</h3>
                            <span class="completion-badge">${completionPercent}%</span>
                        </div>
                        <div class="unit-title">${unitName}</div>
                        <div class="unit-stats">
                            <span>${lessonCount} lessons</span>
                            <span>•</span>
                            <span>${questionCount} questions</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${completionPercent}%"></div>
                        </div>
                    </div>
                `;
            });

            questionsContainer.innerHTML = `
                <div class="curriculum-overview">
                    <h2>📚 AP Statistics Curriculum</h2>
                    <p style="text-align: center; color: #666;">Loaded ${sortedUnits.length} units</p>
                    <div class="units-grid">
                        ${unitsHtml}
                    </div>

                    <!-- Sync Modal -->

                </div>
            `;
        }

        // Function to select a unit
        window.selectUnit = function(unitNumber) {
            currentUnit = unitNumber;
            const unitData = allCurriculumData[unitNumber];
            allUnitQuestions = unitData.questions;

            // Render lesson selector for this unit
            renderLessonSelector(unitData.unitInfo);
        }

        // Modify backToUnits function to go back to unit menu instead
        window.backToUnits = function() {
            // Clear any existing charts
            Object.values(chartInstances).forEach(chart => {
                if (chart && typeof chart.destroy === 'function') {
                    chart.destroy();
                }
            });
            chartInstances = {};
            currentQuestions = [];
            currentUnit = null;
            currentLesson = null;

            // Show unit menu instead of file upload
            renderUnitMenu();
        }


        // Add this function to load resources from allUnitsData.js if it exists
        async function loadUnitResources() {
            try {
                // Check if ALL_UNITS_DATA exists (from allUnitsData.js)
                if (typeof ALL_UNITS_DATA !== 'undefined') {
                    console.log('Found ALL_UNITS_DATA, integrating resources...');
                    return ALL_UNITS_DATA;
                }

                // Try to dynamically load the file if not already loaded
                const script = document.createElement('script');
                script.src = 'allUnitsData.js';

                return new Promise((resolve, reject) => {
                    script.onload = () => {
                        if (typeof ALL_UNITS_DATA !== 'undefined') {
                            console.log('Loaded ALL_UNITS_DATA from file');
                            resolve(ALL_UNITS_DATA);
                        } else {
                            resolve(null);
                        }
                    };
                    script.onerror = () => resolve(null);
                    document.head.appendChild(script);
                });
            } catch (error) {
                console.log('No resources file found');
                return null;
            }
        }

        // Modified renderLessonSelector to show video resources
        async function renderLessonSelectorWithResources(unitInfo) {
            const questionsContainer = document.getElementById('questionsContainer');

            // Load resources if available
            const resources = await loadUnitResources();
            const unitResources = resources ?
                resources.find(u => u.unitId === `unit${currentUnit}`) : null;

            let lessonButtonsHtml = '';

            if (unitInfo && unitInfo.lessonNumbers) {
                unitInfo.lessonNumbers.forEach(lessonNum => {
                    const questions = unitInfo.lessons[lessonNum];
                    const isCompleted = questions.every(q => isQuestionAnswered(q.id));
                    const displayName = lessonNum === 'PC' ? 'Progress Check' : `Lesson ${lessonNum}`;
                    const buttonId = lessonNum === 'PC' ? 'lesson-btn-PC' : `lesson-btn-${lessonNum}`;

                    // Find matching resources for this lesson
                    let resourceInfo = '';
                    if (unitResources && lessonNum !== 'PC') {
                        const topicId = `${currentUnit}-${lessonNum}`;
                        const topic = unitResources.topics.find(t => t.id === topicId);
                        if (topic && topic.videos && topic.videos.length > 0) {
                            resourceInfo = `<span style="color: #4CAF50;">📹 ${topic.videos.length} video${topic.videos.length > 1 ? 's' : ''}</span>`;
                        }
                    }

                    lessonButtonsHtml += `
                        <button onclick="loadLesson('${lessonNum}')"
                                class="lesson-btn ${isCompleted ? 'completed' : ''}"
                                id="${buttonId}">
                            ${displayName}<br>
                            <small>${questions.length} questions</small>
                            ${resourceInfo ? `<br><small>${resourceInfo}</small>` : ''}
                        </button>
                    `;
                });

                questionsContainer.innerHTML = `
                    <button onclick="backToUnits()" class="back-button">← Back to Units</button>
                    <div class="lesson-selector">
                        <h3>Unit ${currentUnit}: ${unitStructure[currentUnit]?.name || 'Unknown Unit'}</h3>
                        <p>Select a lesson to begin:</p>
                        <div class="lesson-buttons">
                            ${lessonButtonsHtml}
                        </div>
                    </div>

                    <!-- Sync Modal -->
                `;
            }
        }

        // Modified loadLesson to show video resources at the top
        window.loadLessonWithResources = async function(lessonNumber) {
            currentLesson = lessonNumber;

            // Get questions for this lesson
            if (lessonNumber === 'PC') {
                currentQuestions = allUnitQuestions.filter(q => q.id.includes('-PC-'));
            } else {
                const lessonNum = parseInt(lessonNumber);
                currentQuestions = allUnitQuestions.filter(q => {
                    if (q.id.includes('-PC-')) return false;
                    const match = q.id.match(/U\d+-L(\d+)-/);
                    return match && parseInt(match[1]) === lessonNum;
                });
            }

            if (currentQuestions.length === 0) {
                showMessage(`No questions found for Lesson ${lessonNumber}`, 'error');
                return;
            }

            // Get resources for this lesson
            const resources = await loadUnitResources();
            let videoSection = '';

            if (resources && lessonNumber !== 'PC') {
                const unitResources = resources.find(u => u.unitId === `unit${currentUnit}`);
                if (unitResources) {
                    const topicId = `${currentUnit}-${lessonNumber}`;
                    const topic = unitResources.topics.find(t => t.id === topicId);

                    if (topic) {
                        videoSection = `
                            <div class="resources-section">
                                <h3>📚 Lesson Resources: ${topic.description}</h3>
                        `;

                        if (topic.videos && topic.videos.length > 0) {
                            videoSection += '<div class="video-resources">';
                            topic.videos.forEach((video, index) => {
                                videoSection += `
                                    <div class="video-item">
                                        <span class="video-number">Video ${index + 1}:</span>
                                        <a href="${video.url}" target="_blank" class="video-link">
                                            AP Classroom Video 📹
                                        </a>
                                        ${video.altUrl ? `
                                            <a href="${video.altUrl}" target="_blank" class="video-link alt">
                                                Alternative Link 🔗
                                            </a>
                                        ` : ''}
                                    </div>
                                `;
                            });
                            videoSection += '</div>';
                        }

                        videoSection += '</div>';
                    }
                }
            }

            // Render quiz with resources
            const questionsContainer = document.getElementById('questionsContainer');
            questionsContainer.innerHTML = `
                <button onclick="backToLessons()" class="back-button">← Back to Lessons</button>
                <div class="app-controls">
                    <div style="flex: 1;">
                        <strong>Unit ${currentUnit}, Lesson ${currentLesson}</strong> - ${currentQuestions.length} questions
                    </div>
                </div>

                ${videoSection}
                <div id="questions-list"></div>
                <div class="loading-msg" id="loading-msg" style="display:none;">Loading questions...</div>
            `;

            const questionsList = document.getElementById('questions-list');
            document.getElementById('loading-msg').style.display = 'block';

            setTimeout(() => {
                currentQuestions.forEach((question, index) => {
                    const questionHtml = renderQuestion(question, index);
                    questionsList.insertAdjacentHTML('beforeend', questionHtml);
                });

                document.getElementById('loading-msg').style.display = 'none';
                loadProgress();

                if (window.MathJax) {
                    MathJax.typesetPromise().catch(e => console.log('MathJax error:', e));
                }

                setTimeout(renderVisibleCharts, 100);
            }, 100);
        }

        // Add styles for the resources section
        const resourceStyles = `
        .resources-section {
            background: #f0f7ff;
            border: 2px solid #2196F3;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .resources-section h3 {
            margin-top: 0;
            color: #1976D2;
        }

        .video-resources {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 15px;
        }

        .video-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: white;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
        }

        .video-number {
            font-weight: bold;
            color: #666;
            min-width: 70px;
        }

        .video-link {
            padding: 6px 12px;
            background: #4CAF50;
            color: white;
            text-decoration: none;
            border-radius: 4px;
            font-size: 14px;
            transition: background 0.3s;
        }

        .video-link:hover {
            background: #45a049;
        }

        .video-link.alt {
            background: #ff9800;
        }

        .video-link.alt:hover {
            background: #f57c00;
        }

        body.dark-theme .resources-section {
            background: #1e3a5f;
            border-color: #5BC0EB;
        }

        body.dark-theme .resources-section h3 {
            color: #5BC0EB;
        }

        body.dark-theme .video-item {
            background: #2d2d2d;
            border-color: #444;
        }

        /* Modal button styles */
        .sync-buttons .modal-btn {
            padding: 10px 20px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
            justify-content: center;
        }

        .sync-buttons .modal-btn:hover {
            background: #1976D2;
        }

        .sync-buttons .modal-btn i {
            font-size: 16px;
        }
        `;

        // Add the styles
        document.head.insertAdjacentHTML('beforeend', `<style>${resourceStyles}</style>`);

        // Update the original functions to use the resource-aware versions
        window.renderLessonSelector = renderLessonSelectorWithResources;
        window.loadLesson = loadLessonWithResources;

        // Sync modal handlers
        window.openSyncModal = function() {
            const modal = document.getElementById('syncModal');
            if (modal) {
                modal.style.display = 'block';
            }
        }

        window.closeSyncModal = function() {
            const modal = document.getElementById('syncModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        // Close modal when clicking outside or on close button
        document.addEventListener('click', function(event) {
            const modal = document.getElementById('syncModal');
            if (event.target === modal || event.target.classList.contains('close-modal')) {
                closeSyncModal();
            }
        });

        // Tab switching functionality
        document.addEventListener('DOMContentLoaded', function() {
            // Handle tab clicks
            const tabs = document.querySelectorAll('.sync-tab');
            const tabContents = document.querySelectorAll('.sync-tab-content');

            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    // Remove active class from all tabs and contents
                    tabs.forEach(t => t.classList.remove('active'));
                    tabContents.forEach(tc => tc.classList.remove('active'));

                    // Add active class to clicked tab
                    tab.classList.add('active');

                    // Show corresponding content
                    const tabName = tab.getAttribute('data-tab');
                    if (tabName === 'local') {
                        document.getElementById('localSyncTab').classList.add('active');
                    } else if (tabName === 'cloud') {
                        document.getElementById('cloudSyncTab').classList.add('active');
                        // Update cloud sync stats when tab is opened
                        if (window.cloudSync) {
                            cloudSync.updateSyncStats();
                        }
                    }
                });
            });

            // Handle auto-sync toggle
            const autoSyncToggle = document.getElementById('autoSyncToggle');
            if (autoSyncToggle) {
                autoSyncToggle.addEventListener('change', function() {
                    if (window.cloudSync) {
                        cloudSync.toggleAutoSync();
                    }
                    document.getElementById('autoSyncStatus').textContent =
                        this.checked ? 'ON' : 'OFF';
                });
            }

            // Two-way sync button
            document.getElementById('syncBothWaysBtn')?.addEventListener('click', async function() {
                if (window.cloudSync) {
                    this.disabled = true;
                    this.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Syncing...';

                    try {
                        await cloudSync.pushToCloud();
                        setTimeout(async () => {
                            await cloudSync.pullFromCloud();
                            this.innerHTML = '<i class="fas fa-sync-alt"></i><span><strong>Two-Way Sync</strong><small>Merge local and cloud data</small></span>';
                            this.disabled = false;
                        }, 1000);
                    } catch (error) {
                        console.error('Two-way sync failed:', error);
                        this.innerHTML = '<i class="fas fa-sync-alt"></i><span><strong>Two-Way Sync</strong><small>Merge local and cloud data</small></span>';
                        this.disabled = false;
                    }
                }
            });
        });

        // Sync button functionality
        document.addEventListener('DOMContentLoaded', function() {

            // Handle Save button click (personal export)
            document.addEventListener('click', function(event) {
                if (event.target.id === 'saveBtn' || event.target.closest('#saveBtn')) {
                    exportPersonal();
                    closeSyncModal();
                }
            });

            // Handle Open button click (smart import)
            document.addEventListener('click', function(event) {
                if (event.target.id === 'openBtn' || event.target.closest('#openBtn')) {
                    // Create hidden file input for smart import
                    let smartImportInput = document.getElementById('smartImportFile');
                    if (!smartImportInput) {
                        smartImportInput = document.createElement('input');
                        smartImportInput.type = 'file';
                        smartImportInput.id = 'smartImportFile';
                        smartImportInput.accept = '.json';
                        smartImportInput.style.display = 'none';
                        smartImportInput.addEventListener('change', handleSmartImport);
                        document.body.appendChild(smartImportInput);
                    }
                    smartImportInput.click();
                    closeSyncModal();
                }
            });

            // Handle Master Import button click
            document.addEventListener('click', function(event) {
                if (event.target.id === 'masterImportBtn' || event.target.closest('#masterImportBtn')) {
                    event.preventDefault(); // Prevent any default behavior
                    event.stopPropagation(); // Stop event bubbling

                    console.log('=== Master Import button clicked ===');
                    // Create hidden file input for master import
                    let masterImportInput = document.getElementById('masterImportFile');
                    if (!masterImportInput) {
                        masterImportInput = document.createElement('input');
                        masterImportInput.type = 'file';
                        masterImportInput.accept = '.json';
                        masterImportInput.id = 'masterImportFile';
                        masterImportInput.style.display = 'none';
                        masterImportInput.addEventListener('change', function(fileEvent) {
                            fileEvent.preventDefault(); // Prevent any default behavior
                            console.log('Master import file selected');
                            const file = fileEvent.target.files[0];
                            if (!file) return;

                            // Reset the file input to allow re-selection of the same file
                            fileEvent.target.value = '';

                            const reader = new FileReader();
                            reader.onload = function(e) {
                                try {
                                    const data = JSON.parse(e.target.result);
                                    console.log('Master import - calling importMasterData with:', data);

                                    // Prevent ALL forms of page refresh/navigation
                                    window.onbeforeunload = function(e) {
                                        console.log('Preventing page refresh during import...');
                                        return 'Import in progress, are you sure you want to leave?';
                                    };

                                    // Capture and prevent any navigation
                                    const originalLocation = window.location.href;
                                    const preventNavigation = () => {
                                        if (window.location.href !== originalLocation) {
                                            window.location.href = originalLocation;
                                        }
                                    };
                                    const navInterval = setInterval(preventNavigation, 10);

                                    try {
                                        console.log('Starting direct localStorage import...');

                                        // Do the import directly here without calling any functions
                                        if (data && data.students) {
                                            const students = data.students;
                                            let importCount = 0;

                                            // Get or create classData structure for peer display
                                            const classData = JSON.parse(localStorage.getItem('classData') || '{}');
                                            if (!classData.users) classData.users = {};

                                            Object.entries(students).forEach(([username, userInfo]) => {
                                                if (userInfo.answers) {
                                                    // STANDARDIZATION FIX: Use migration function for consistency
                                                    const standardizedAnswers = migrateAnswersToStandardFormat(userInfo.answers);

                                                    // Store individual keys (for existing functionality)
                                                    localStorage.setItem(`answers_${username}`, JSON.stringify(standardizedAnswers));

                                                    // ALSO store in classData structure (for peer display)
                                                    if (!classData.users[username]) {
                                                        classData.users[username] = { answers: {}, reasons: {}, timestamps: {}, attempts: {} };
                                                    }
                                                    Object.assign(classData.users[username].answers, standardizedAnswers);

                                                    importCount++;
                                                }
                                                if (userInfo.progress) {
                                                    localStorage.setItem(`progress_${username}`, JSON.stringify(userInfo.progress));
                                                }
                                                if (userInfo.reasons) {
                                                    localStorage.setItem(`reasons_${username}`, JSON.stringify(userInfo.reasons));
                                                    Object.assign(classData.users[username].reasons, userInfo.reasons);
                                                }
                                                if (userInfo.timestamps) {
                                                    localStorage.setItem(`timestamps_${username}`, JSON.stringify(userInfo.timestamps));
                                                    Object.assign(classData.users[username].timestamps, userInfo.timestamps);
                                                }
                                                if (userInfo.attempts) {
                                                    localStorage.setItem(`attempts_${username}`, JSON.stringify(userInfo.attempts));
                                                    Object.assign(classData.users[username].attempts, userInfo.attempts);
                                                }
                                            });

                                            // Save the updated classData structure
                                            localStorage.setItem('classData', JSON.stringify(classData));

                                            // CRITICAL: Refresh the global classData variable
                                            window.classData = classData;

                                            // Also call initClassData to ensure everything is properly loaded
                                            if (typeof initClassData === 'function') {
                                                initClassData();
                                            }

                                            console.log(`Imported data for ${importCount} students`);
                                            console.log('Global classData updated:', window.classData);
                                            alert(`✅ Imported data for ${importCount} students! Peer answers should now be visible.`);
                                        } else {
                                            alert('❌ No students data found in file');
                                        }
                                    } catch (error) {
                                        console.error('Import failed:', error);
                                        alert('❌ Import failed: ' + error.message);
                                    } finally {
                                        // Clean up after import
                                        clearInterval(navInterval);
                                        window.onbeforeunload = null;
                                    }

                                } catch (error) {
                                    console.error('Master import error:', error);
                                    alert('❌ Error importing master database: ' + error.message);
                                }
                            };
                            reader.readAsText(file);
                        });
                        document.body.appendChild(masterImportInput);
                    }

                    // Use setTimeout to prevent any refresh issues
                    setTimeout(() => {
                        masterImportInput.click();
                    }, 50);

                    // Don't close modal immediately - let import complete first
                    setTimeout(() => {
                        closeSyncModal();
                    }, 200);
                }
            });

            // Handle Master Export button click
            document.addEventListener('click', function(event) {
                if (event.target.id === 'masterExportBtn' || event.target.closest('#masterExportBtn')) {
                    exportMasterData();
                    closeSyncModal();
                }
            });
        });
  // --- File Type Detection Functions ---

  /**
   * Detects if the imported data is a personal data file
   * Personal files have username and users object with the user's data
   */
   function isPersonalDataFile(data) {
      // Check for personal export format
      if (data.username && data.users && data.users[data.username]) {
          return true;
      }

      // Check for single user export with answers directly
      if (data.username && data.answers) {
          return true;
      }

      // Check if it has a single user in users object
      if (data.users && Object.keys(data.users).length === 1) {
          return true;
      }

      return false;
  }

  /**
   * Detects if the imported data is a master data file
   * Master files have multiple users or explicit master export type
   */
  function isMasterDataFile(data) {
      // Check for explicit master export type
      if (data.exportType === 'master_database') {
          return true;
      }

      // Check for multiple users
      if (data.users && Object.keys(data.users).length > 1) {
          return true;
      }

      // Check for master export format with allUsers
      if (data.allUsers && Array.isArray(data.allUsers)) {
          return true;
      }

      return false;
  }

  // --- End of File Type Detection Functions ---
        // Smart Import Function - Auto-detects file type
        function handleSmartImport(event) {
            console.log('handleSmartImport called', event);
            const file = event.target.files[0];
            console.log('Selected file:', file);
            if (!file) {
                console.log('No file selected');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);

                    // Detect file type and handle appropriately
                    const debugInfo = {
                        dataKeys: Object.keys(data),
                        isPersonal: isPersonalDataFile(data),
                        isMaster: isMasterDataFile(data),
                        timestamp: new Date().toISOString()
                    };

                    // Store debug info to survive page refresh
                    localStorage.setItem('import_debug', JSON.stringify(debugInfo));
                    
                    console.log('File import debug - data keys:', Object.keys(data));

  // Direct detection logic without external functions
  let isPersonalFile = false;
  let isMasterFile = false;

  // Check for personal file formats
  if (data.username && data.users && data.users[data.username]) {
      // Standard personal export format
      isPersonalFile = true;
      console.log('Detected: Personal export format with username and users');
  } else if (data.username && data.answers) {
      // Alternative personal format with direct answers
      isPersonalFile = true;
      console.log('Detected: Personal format with direct answers');
  } else if (data.users && Object.keys(data.users).length === 1) {
      // Single user export
      isPersonalFile = true;
      console.log('Detected: Single user export format');
  } else if (data.users && Object.keys(data.users).length > 1) {
      // Multiple users - master file
      isMasterFile = true;
      console.log('Detected: Master file with multiple users');
  } else if (data.exportType === 'master_database') {
      // Explicit master export
      isMasterFile = true;
      console.log('Detected: Master database export');
  }

  console.log('File import debug - isPersonalFile:', isPersonalFile);
  console.log('File import debug - isMasterFile:', isMasterFile);

  // Process based on file type
  if (isPersonalFile) {
      console.log('Processing as personal data file...');
      importAndMergePersonalData(data);
      // Message is handled inside importAndMergePersonalData
      return;
  } else if (isMasterFile) {
      console.log('Processing as master data file...');
      importMasterData(data);
      showMessage('✅ Master data imported successfully!', 'success');
      return;
  } else {
      console.error('File structure does not match expected formats');
      console.log('Data sample:', JSON.stringify(data, null, 2).substring(0, 500) + '...');
      showMessage('⚠️ Unrecognized file format. Please check your file.', 'error');
  }

                    // Store the data temporarily to survive refresh
                    if (isMasterDataFile(data)) {
                        localStorage.setItem('pending_master_import', JSON.stringify(data));
                        console.log('Stored master data for import after refresh');
                    } else if (isPersonalDataFile(data)) {
                        localStorage.setItem('pending_personal_import', JSON.stringify(data));
                        console.log('Stored personal data for import after refresh');
                    }

                    // Prevent immediate actions that might cause refresh
                    setTimeout(() => {
                        if (isPersonalDataFile(data)) {
                            console.log('Detected: Personal data file');
                            importAndMergePersonalData(data);
  // Message is now handled inside importAndMergePersonalData for better feedback
                          } else if (isMasterDataFile(data)) {
                            console.log('Detected: Master database file');
                            importMasterData(data);
                            showMessage('✅ Master database imported successfully!', 'success');
                        } else {
                            console.log('File structure does not match expected formats');
                            console.log('Data sample:', JSON.stringify(data, null, 2).substring(0, 500));
                            showMessage('❌ Unrecognized file format. Please check your file.', 'error');
                        }
                    }, 500);
                } catch (error) {
                    console.error('Import error:', error);
                    showMessage('❌ Error reading file. Please check the file format.', 'error');
                }
            };
            reader.readAsText(file);
        }

        // File type detection functions
        function isPersonalDataFile(data) {
            // Personal data files typically have a single user's answers and progress
            return (data.answers && typeof data.answers === 'object') ||
                   (data.username && data.exportType === 'personal') ||
                   (data.progress && !data.students && !data.allUsers);
        }

        function isMasterDataFile(data) {
            // Master data files have multiple users or class-wide data
            return !!(data.students ||
                     data.allUsers ||
                     data.exportType === 'master_database' ||
                     (data.users && Object.keys(data.users).length > 1));
        }

        // Backward compatibility migration function
        function migrateAnswersToStandardFormat(answers) {
            const standardizedAnswers = {};
            const currentTime = Date.now();

            Object.entries(answers).forEach(([questionId, answer]) => {
                if (typeof answer === 'object' && answer.value !== undefined) {
                    // Already in new format
                    standardizedAnswers[questionId] = answer;
                } else {
                    // Convert from simple string format to object format
                    standardizedAnswers[questionId] = {
                        value: answer,
                        timestamp: currentTime
                    };
                }
            });

            return standardizedAnswers;
        }

        // Import functions for different file types
        function importPersonalData(data) {
            if (!currentUsername) {
                showMessage('❌ Please select a username first.', 'error');
                return;
            }

            // Import answers with standardization
            if (data.answers) {
                const standardizedAnswers = migrateAnswersToStandardFormat(data.answers);
                localStorage.setItem(`answers_${currentUsername}`, JSON.stringify(standardizedAnswers));
                console.log(`✓ Imported personal answers for ${currentUsername} (standardized format)`);
            }

            // Import progress
            if (data.progress) {
                localStorage.setItem(`progress_${currentUsername}`, JSON.stringify(data.progress));
            }

            // Reinitialize to show imported data
            initClassData();
            if (typeof renderUnitMenu === 'function') {
                renderUnitMenu();
            }
        }

        function importMasterData(data, targetUsername = null) {
            console.log('=== importMasterData called ===');
            console.log('Data passed to importMasterData:', data);
            console.log('Target username for restoration:', targetUsername);

            // Use existing master data import functionality
            if (typeof mergeMasterData === 'function') {
                console.log('Found mergeMasterData function, using it');
                mergeMasterData(data);
            } else {
                console.warn('No mergeMasterData function found, attempting basic import...');
                console.log('Import data structure:', data);
                console.log('Data keys:', Object.keys(data));
                console.log('Has students property:', !!data.students);
                console.log('Has allUsers property:', !!data.allUsers);
                console.log('Has users property:', !!data.users);

                // Try different possible structures
                let userData = null;
                if (data.students) {
                    userData = data.students;
                    console.log('Using data.students:', userData);
                } else if (data.allUsers) {
                    userData = data.allUsers;
                    console.log('Using data.allUsers:', userData);
                } else if (data.users) {
                    userData = data.users;
                    console.log('Using data.users:', userData);
                }

                if (userData) {
                    // Check if this is single-user restoration (from username screen)
                    if (targetUsername && userData[targetUsername]) {
                        console.log(`SINGLE-USER RESTORATION: Importing only data for ${targetUsername}`);
                        const userInfo = userData[targetUsername];

                        if (userInfo.answers) {
                            // STANDARDIZATION FIX: Use migration function for consistency
                            const standardizedAnswers = migrateAnswersToStandardFormat(userInfo.answers);
                            localStorage.setItem(`answers_${targetUsername}`, JSON.stringify(standardizedAnswers));
                            console.log(`✓ Restored answers for ${targetUsername} (standardized format)`);
                        }
                        if (userInfo.progress) {
                            localStorage.setItem(`progress_${targetUsername}`, JSON.stringify(userInfo.progress));
                            console.log(`✓ Restored progress for ${targetUsername}`);
                        }
                        if (userInfo.reasons) {
                            localStorage.setItem(`reasons_${targetUsername}`, JSON.stringify(userInfo.reasons));
                            console.log(`✓ Restored reasons for ${targetUsername}`);
                        }
                        if (userInfo.timestamps) {
                            localStorage.setItem(`timestamps_${targetUsername}`, JSON.stringify(userInfo.timestamps));
                            console.log(`✓ Restored timestamps for ${targetUsername}`);
                        }
                        if (userInfo.attempts) {
                            localStorage.setItem(`attempts_${targetUsername}`, JSON.stringify(userInfo.attempts));
                            console.log(`✓ Restored attempts for ${targetUsername}`);
                        }

                        console.log(`=== Single-user restoration completed for ${targetUsername} ===`);
                        return;
                    }

                    // Otherwise, do multi-user peer import
                    console.log('MULTI-USER PEER IMPORT: Importing data for', Object.keys(userData).length, 'students');
                    console.log('Student usernames:', Object.keys(userData));

                    // Get or create classData structure for peer display
                    const classData = JSON.parse(localStorage.getItem('classData') || '{}');
                    if (!classData.users) classData.users = {};

                    Object.entries(userData).forEach(([username, userInfo]) => {
                        console.log(`Processing user: ${username}`, userInfo);

                        if (userInfo.answers) {
                            // STANDARDIZATION FIX: Use migration function for consistency
                            const standardizedAnswers = migrateAnswersToStandardFormat(userInfo.answers);

                            // Store individual keys (for existing functionality)
                            const key = `answers_${username}`;
                            localStorage.setItem(key, JSON.stringify(standardizedAnswers));
                            console.log(`✓ Stored answers for ${username} in ${key} (standardized format)`);

                            // ALSO store in classData structure (for peer display)
                            if (!classData.users[username]) {
                                classData.users[username] = { answers: {}, reasons: {}, timestamps: {}, attempts: {} };
                            }
                            Object.assign(classData.users[username].answers, standardizedAnswers);
                            console.log(`✓ Added ${username} to classData structure`);
                        } else {
                            console.log(`⚠ No answers found for ${username}`);
                        }

                        if (userInfo.progress) {
                            const key = `progress_${username}`;
                            localStorage.setItem(key, JSON.stringify(userInfo.progress));
                            console.log(`✓ Stored progress for ${username} in ${key}`);
                        }

                        if (userInfo.reasons) {
                            localStorage.setItem(`reasons_${username}`, JSON.stringify(userInfo.reasons));
                            if (classData.users[username]) {
                                Object.assign(classData.users[username].reasons, userInfo.reasons);
                            }
                        }

                        if (userInfo.timestamps) {
                            localStorage.setItem(`timestamps_${username}`, JSON.stringify(userInfo.timestamps));
                            if (classData.users[username]) {
                                Object.assign(classData.users[username].timestamps, userInfo.timestamps);
                            }
                        }

                        if (userInfo.attempts) {
                            localStorage.setItem(`attempts_${username}`, JSON.stringify(userInfo.attempts));
                            if (classData.users[username]) {
                                Object.assign(classData.users[username].attempts, userInfo.attempts);
                            }
                        }
                    });

                    // Save the updated classData structure
                    localStorage.setItem('classData', JSON.stringify(classData));
                    console.log(`✓ Updated classData with ${Object.keys(classData.users).length} users`);

                    // CRITICAL: Refresh the global classData variable
                    window.classData = classData;

                    // Reinitialize to show imported data
                    if (typeof initClassData === 'function') {
                        console.log('Calling initClassData()');
                        initClassData();
                    }
                    if (typeof renderUnitMenu === 'function') {
                        console.log('Calling renderUnitMenu()');
                        renderUnitMenu();
                    }
                    console.log('=== Master data import completed ===');
                } else {
                    console.warn('❌ No students data found in import file');
                    console.log('Available data keys:', Object.keys(data));
                }
            }
        }

        // Update references from masterExportBtn to totalExportBtn
        window.exportMasterData = window.exportMasterData || function() {
            // Get ALL data from localStorage, not filtered by user
            const masterData = {
                exportTime: new Date().toISOString(),
                exportType: 'master_database',
                allUsers: Object.keys(localStorage)
                    .filter(key => key.includes('_username') || key.includes('answers_'))
                    .map(key => key.split('_')[1])
                    .filter((v, i, a) => a.indexOf(v) === i), // unique usernames

                // Get all class data without filtering
                classData: JSON.parse(localStorage.getItem('classData') || '{}'),

                // Get all answers from all users
                allAnswers: {},
                allProgress: {},

                // Include raw localStorage for complete backup
                rawLocalStorage: {}
            };

            // Collect all answers for all users
            Object.keys(localStorage).forEach(key => {
                if (key.startsWith('answers_')) {
                    const username = key.replace('answers_', '');
                    masterData.allAnswers[username] = JSON.parse(localStorage.getItem(key) || '{}');
                }
                if (key.startsWith('progress_')) {
                    const username = key.replace('progress_', '');
                    masterData.allProgress[username] = JSON.parse(localStorage.getItem(key) || '{}');
                }
                masterData.rawLocalStorage[key] = localStorage.getItem(key);
            });

            // Create and download the file
            const blob = new Blob([JSON.stringify(masterData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `master_database_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showMessage('Master database exported successfully!', 'success');
        }

        // Initialize sync functionality
        function initializeSyncModal() {
            // Update current user display
            const currentUserDisplay = document.getElementById('currentUserDisplay');
            if (currentUserDisplay) {
                currentUserDisplay.textContent = localStorage.getItem('consensusUsername') || 'Unknown';
            }

            // Ensure Master Import button exists (add dynamically if missing)
            const masterExportBtn = document.getElementById('masterExportBtn');
            if (masterExportBtn && !document.getElementById('masterImportBtn')) {
                console.log('Master Import button missing, adding it dynamically');
                const masterImportBtn = document.createElement('button');
                masterImportBtn.id = 'masterImportBtn';
                masterImportBtn.className = 'modal-btn';
                masterImportBtn.innerHTML = `
                    <i class="fas fa-cloud-download-alt"></i>
                    <span>
                        <strong>Master Import</strong>
                        <small>Import peer data from master database</small>
                    </span>
                `;
                masterExportBtn.parentNode.appendChild(masterImportBtn);
                console.log('Master Import button added dynamically');
            }
        }

        // Show sync modal
        function showSyncModal() {
            initializeSyncModal();

            const modal = document.getElementById('syncModal');
            if (modal) {
                modal.style.display = 'block';

                // Debug: Check if Master Import button exists and add if missing
                setTimeout(() => {
                    let masterImportBtn = document.getElementById('masterImportBtn');
                    console.log('Master Import button exists:', !!masterImportBtn);

                    if (masterImportBtn) {
                        console.log('Master Import button element:', masterImportBtn);
                    } else {
                        console.error('Master Import button NOT FOUND in DOM!');
                        console.log('All buttons in modal:', modal.querySelectorAll('button'));

                        // Force add the button
                        const masterExportBtn = document.getElementById('masterExportBtn');
                        if (masterExportBtn) {
                            console.log('Adding Master Import button manually...');
                            masterImportBtn = document.createElement('button');
                            masterImportBtn.id = 'masterImportBtn';
                            masterImportBtn.className = 'modal-btn';
                            masterImportBtn.innerHTML = `
                                <i class="fas fa-cloud-download-alt"></i>
                                <span>
                                    <strong>Master Import</strong>
                                    <small>Import peer data from master database</small>
                                </span>
                            `;
                            masterExportBtn.parentNode.appendChild(masterImportBtn);
                            console.log('Master Import button added manually!');
                        }
                    }
                }, 100);
            } else {
                console.error('Sync modal element not found!');
                // Fallback: try to find any modal with sync-related content
                const allModals = document.querySelectorAll('.modal');
                console.log('Available modals:', allModals);
            }
        }

        // Runtime migration function to update existing localStorage data
        function migrateExistingAnswersData() {
            console.log('Checking for existing answers data that needs migration...');
            let migrationCount = 0;

            Object.keys(localStorage).forEach(key => {
                if (key.startsWith('answers_')) {
                    try {
                        const answers = JSON.parse(localStorage.getItem(key));
                        let needsMigration = false;

                        // Check if any answers are still in simple string format
                        for (const questionId in answers) {
                            if (typeof answers[questionId] !== 'object' || answers[questionId].value === undefined) {
                                needsMigration = true;
                                break;
                            }
                        }

                        if (needsMigration) {
                            const standardizedAnswers = migrateAnswersToStandardFormat(answers);
                            localStorage.setItem(key, JSON.stringify(standardizedAnswers));
                            migrationCount++;
                            console.log(`✓ Migrated ${key} to standardized format`);
                        }
                    } catch (error) {
                        console.error(`Error migrating ${key}:`, error);
                    }
                }
            });

            if (migrationCount > 0) {
                console.log(`✅ Migrated ${migrationCount} answer datasets to standardized format`);
            } else {
                console.log('✅ All existing answer data is already in standardized format');
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Run migration on existing data
            migrateExistingAnswersData();

            // Set up sync button
            const syncBtn = document.getElementById('syncBtn');
            if (syncBtn) {
                syncBtn.addEventListener('click', showSyncModal);
            }

            // Set up share modal event listeners
            const shareModal = document.getElementById('shareModal');
            if (shareModal) {
                // Close modal when clicking outside
                window.addEventListener('click', function(event) {
                    if (event.target === shareModal) {
                        closeShareModal();
                    }
                });

                // Close modal with ESC key
                document.addEventListener('keydown', function(event) {
                    if (event.key === 'Escape' && shareModal.style.display === 'block') {
                        closeShareModal();
                    }
                });
            }

            // Check for initial page load and add share info
            const questionsContainer = document.getElementById('questionsContainer');
            if (questionsContainer) {
                // Check if we're on initial/username page
                const currentUsername = localStorage.getItem('consensusUsername');
                if (!currentUsername) {
                    // Add share button to initial page
                    const shareHtml = `
                        <div style="text-align: center; margin: 30px 0;">
                            <h2>Welcome to AP Stats Consensus Quiz!</h2>
                            <p style="margin: 15px 0;">A collaborative learning platform for AP Statistics</p>
                            <button onclick="showShareModal()" style="
                                background: #9b59b6;
                                color: white;
                                border: none;
                                padding: 15px 30px;
                                border-radius: 8px;
                                font-size: 18px;
                                cursor: pointer;
                                margin: 20px 10px;
                                transition: all 0.3s ease;
                            " onmouseover="this.style.background='#8e44ad'" onmouseout="this.style.background='#9b59b6'">
                                📤 Share This App
                            </button>
                            <p style="margin-top: 20px; color: #666;">
                                <small>New to this app? Click the share button to learn more!</small>
                            </p>
                        </div>
                    `;
                    questionsContainer.innerHTML = shareHtml + questionsContainer.innerHTML;
                }
            }
        });

    </script>
</body>
</html>
